<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>vdW interactions and thermal radiation functions · AARMBEM.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AARMBEM.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../theory/historicalbackground.html">History</a></li><li><a class="tocitem" href="../theory/theoreticalbackground.html">Theory</a></li><li><a class="tocitem" href="../theory/acronyms.html">Common acronyms</a></li></ul></li><li><span class="tocitem">Implementation Notes</span><ul><li><a class="tocitem" href="../implementation/units.html">Units</a></li><li><a class="tocitem" href="../implementation/matrixstorage.html">Matrix storage conventions</a></li><li><a class="tocitem" href="../implementation/datastructuresandtransformations.html">Data structures and rigid transformations</a></li><li><a class="tocitem" href="../implementation/performancenotes.html">Performance notes and required packages</a></li><li><a class="tocitem" href="../implementation/outputquantities.html">Output quantities</a></li><li><a class="tocitem" href="../implementation/ewaldwarning.html">Warning: Ewald summation</a></li></ul></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../usage/configfiles.html">Configuration files</a></li><li><a class="tocitem" href="../usage/transfiles.html">Transformation files</a></li><li><a class="tocitem" href="../usage/periodicfiles.html">Bloch periodicity files</a></li><li><a class="tocitem" href="../usage/freqkfiles.html">Frequency and Bloch wavevector files</a></li><li><a class="tocitem" href="../usage/CMDARGS.html">Command-line arguments</a></li><li><a class="tocitem" href="../usage/outfiles.html">Output file structure</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/guaninecytosinePEC.html">Guanine + cytosine + PEC plane</a></li><li><a class="tocitem" href="../examples/2grapheneVAC.html">Two identical parallel graphene sheets (vacuum)</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="CMDARGS.html">Command-line arguments</a></li><li><a class="tocitem" href="expintegral.html">Exponential integral function</a></li><li><a class="tocitem" href="genericmatrixvectorutils.html">Generic matrix and vector utilities</a></li><li><a class="tocitem" href="greensfunctions.html">Maxwell Green&#39;s functions</a></li><li><a class="tocitem" href="periodicdata.html">Data structures and functions for Bloch periodicity</a></li><li><a class="tocitem" href="moldata.html">Molecular data structures and methods</a></li><li><a class="tocitem" href="transdata.html">Transformation data structures and methods</a></li><li class="is-active"><a class="tocitem" href="vdWRHT.html">vdW interactions and thermal radiation functions</a><ul class="internal"><li><a class="tocitem" href="#Thermal-radiation-1"><span>Thermal radiation</span></a></li><li><a class="tocitem" href="#vdW-interactions-1"><span>vdW interactions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="vdWRHT.html">vdW interactions and thermal radiation functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="vdWRHT.html">vdW interactions and thermal radiation functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/psv2/AARMBEM.jl/blob/master/doc/src/api/vdWRHT.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="vdW-interactions-and-thermal-radiation-functions-1"><a class="docs-heading-anchor" href="#vdW-interactions-and-thermal-radiation-functions-1">vdW interactions and thermal radiation functions</a><a class="docs-heading-anchor-permalink" href="#vdW-interactions-and-thermal-radiation-functions-1" title="Permalink"></a></h1><h2 id="Thermal-radiation-1"><a class="docs-heading-anchor" href="#Thermal-radiation-1">Thermal radiation</a><a class="docs-heading-anchor-permalink" href="#Thermal-radiation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="heattransfer" href="#heattransfer"><code>heattransfer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">heattransfer(myARGS)</code></pre><p>Extract command-line arguments for computing the radiative heat transfer among a collection of molecules, then compute the radiative heat transfer appropriately.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Any frequencies will be converted to their absolute values. Frequencies are not allowed to be exactly zero.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This computes the integrand <span>$\operatorname{Tr}(\operatorname{asym}(\mathbb{V}_{m}^{-1}) \mathbb{P}_{m} \mathbb{T}^{\dagger} \operatorname{asym}(\mathbb{P}_{n} \mathbb{G}^{\mathrm{env}}) \mathbb{T}\mathbb{P}_{m})$</span> at specified real frequencies, without doing any integration. This includes neither numerical prefactors outside of the trace, nor the Planck function.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This function can be embarrassingly parallelized over frequency and wavevector. However, the integrand at each frequency and wavevector is calculated for every transformation, as this maximizes the efficiency of the program by virtue of reusing quantities independent of geometric transformations.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/heattransfer.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="heattransfer_general" href="#heattransfer_general"><code>heattransfer_general</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">heattransfer_general(outfilename, myAllMolData, myTransData, myPeriodicData, Genvstr,
                     nonretarded, freqklist)</code></pre><p>Compute the actual radiative heat transfer integrand and print it to <code>outfilename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/heattransfer.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="assemblePhimn!" href="#assemblePhimn!"><code>assemblePhimn!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assemblePhimn!(Phimn::Array{FT, 2},
               myAllMolData::MolSystem{OneMol_WithPhonons{FT}},
               myPeriodicData::PeriodicData{FT},
               totalTmat::SharedArray{Complex{FT}, 2},
               totalGenvmat::SharedArray{Complex{FT}, 2})</code></pre><p>Assemble the matrix <code>Phimn</code>, whose elements <code>Phimn[nn1, nn2]</code> represent the energy transfer from molecule <code>nn1</code> to molecule <code>nn2</code>, computed from trace expressions involving the matrices <code>totalTmat</code> and <code>totalGenvmat</code>, in-place. If there is no spatial periodicity, <code>Phimn</code> should be symmetric. If there is spatial periodicity, the transpose of <code>Phimn</code> at wavevector <span>$\vec{k}$</span> is the equivalent of computing <code>Phimn</code> at <span>$-\vec{k}$</span>. This assumes the presence of phonons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/heattransfer.jl#L237-L252">source</a></section><section><div><pre><code class="language-none">assemblePhimn!(Phimn::Array{FT, 2},
               myAllMolData::MolSystem{OneMol_NoPhonons{FT}},
               myPeriodicData::PeriodicData{FT},
               totalTmat::SharedArray{Complex{FT}, 2},
               totalGenvmat::SharedArray{Complex{FT}, 2})</code></pre><p>Assemble the matrix <code>Phimn</code>, whose elements <code>Phimn[nn1, nn2]</code> represent the energy transfer from molecule <code>nn1</code> to molecule <code>nn2</code>, computed from trace expressions involving the matrices <code>totalTmat</code> and <code>totalGenvmat</code>, in-place. If there is no spatial periodicity, <code>Phimn</code> should be symmetric. If there is spatial periodicity, the transpose of <code>Phimn</code> at wavevector <span>$\vec{k}$</span> is the equivalent of computing <code>Phimn</code> at <span>$-\vec{k}$</span>. This assumes the absence of phonons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/heattransfer.jl#L305-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="assembleTinvGenvDiagBlock!" href="#assembleTinvGenvDiagBlock!"><code>assembleTinvGenvDiagBlock!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assembleTinvGenvDiagBlock!(totalTinvmat::SharedArray{Complex{FT}, 2},
                           totalGenvmat::SharedArray{Complex{FT}, 2},
                           myAllMolData::MolSystem{OneMol_WithPhonons{FT}},
                           myTransData::TransData{FT}, nn2::Integer,
                           currmolind2::Integer, startidx2::Integer,
                           tt::Integer, myPeriodicData::PeriodicData{FT},
                           GFSCAGG!::Function,
                           currfreqG::Union{FT, Complex{FT}},
                           currk::Array{FT, 1}=zeros(FT, 3)) where FT&lt;:AbstractFloat</code></pre><p>Assemble the molecular diagonal block of the scattering Green&#39;s function interaction matrix of molecule <code>nn2</code> (whose unique molecular index <code>currmolind2</code> is precomputed and passed as an argument) at frequency <code>currfreqG</code> and wavevector <code>currk</code> using <code>GFSCAGG!</code>, then add the vacuum contribution of molecule <code>nn2</code>, performing any required matrix rotations corresponding to transformation <code>tt</code> for molecule <code>nn2</code>. Stamp that added to coincident contributions into <code>totalGenvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]</code>, or that (without coincident contributions) subtracted from the inverse molecular susceptibility into <code>totalTinvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]</code>. Finally, undo any rotation corresponding to transformation <code>tt</code> in the inverse T-operator of molecule <code>nn2</code> for reuse with future transformations. This assumes the presence of phonons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/heattransfer.jl#L373-L398">source</a></section><section><div><pre><code class="language-none">assembleTinvGenvDiagBlock!(totalTinvmat::SharedArray{Complex{FT}, 2},
                           totalGenvmat::SharedArray{Complex{FT}, 2},
                           myAllMolData::MolSystem{OneMol_NoPhonons{FT}},
                           myTransData::TransData{FT}, nn2::Integer,
                           currmolind2::Integer,
                           startidx2::Integer,
                           tt::Integer, myPeriodicData::PeriodicData{FT},
                           GFSCAGG!::Function,
                           currfreqG::Union{FT, Complex{FT}},
                           currk::Array{FT, 1}=zeros(FT, 3)) where FT&lt;:AbstractFloat</code></pre><p>Assemble the molecular diagonal block of the scattering Green&#39;s function interaction matrix of molecule <code>nn2</code> (whose unique molecular index <code>currmolind2</code> is precomputed and passed as an argument) at frequency <code>currfreqG</code> and wavevector <code>currk</code> using <code>GFSCAGG!</code>, then add the vacuum contribution of molecule <code>nn2</code>, performing any required matrix rotations corresponding to transformation <code>tt</code> for molecule <code>nn2</code>. Stamp that added to coincident contributions into <code>totalGenvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]</code>, or that (without coincident contributions) subtracted from the inverse molecular susceptibility into <code>totalTinvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]</code>. Finally, undo any rotation corresponding to transformation <code>tt</code> in the inverse T-operator of molecule <code>nn2</code> for reuse with future transformations. This assumes the absence of phonons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/heattransfer.jl#L444-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="assembleTinvGenvOffDiagBlock!" href="#assembleTinvGenvOffDiagBlock!"><code>assembleTinvGenvOffDiagBlock!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assembleTinvGenvOffDiagBlock!(totalTinvmat::SharedArray{Complex{FT}, 2},
                              totalGenvTinvmat::SharedArray{Complex{FT}, 2},
                              myAllMolData::MolSystem{&lt;:OneMol{FT}},
                              myTransData::TransData{FT},
                              nn1::Integer, nn2::Integer,
                              startidx1::Integer,
                              startidx2::Integer,
                              myPeriodicData::PeriodicData{FT},
                              GFSCAGG!::Function,
                              currfreqG::Union{FT, Complex{FT}},
                              currk::Array{FT, 1}=zeros(FT, 3)) where FT&lt;:AbstractFloat</code></pre><p>Assemble the molecular off-diagonal block of the scattering Green&#39;s function interaction matrix of molecules <code>nn2</code> as the source and <code>nn1</code> as the field (whose respective unique molecular indices <code>currmolind1</code> and <code>currmolind2</code> are precomputed and passed as arguments) at frequency <code>currfreqG</code> and wavevector <code>currk</code> using <code>GFSCAGG!</code>, multiply on the left by the electronic polarizabilities, add the vacuum contribution, and stamp that into <code>totalGenvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]</code> and its negative into <code>totalTinvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]</code>. If there is no spatial periodicity, do the same for the (unconjugated) transpose, swapping <code>nn2</code> and <code>nn1</code> without performing further Green&#39;s function computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/heattransfer.jl#L510-L536">source</a></section></article><h2 id="vdW-interactions-1"><a class="docs-heading-anchor" href="#vdW-interactions-1">vdW interactions</a><a class="docs-heading-anchor-permalink" href="#vdW-interactions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="vdWenergy" href="#vdWenergy"><code>vdWenergy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vdWenergy(myARGS)</code></pre><p>Extract command-line arguments for computing the vdW interaction energy among a collection of molecules, then compute the vdW energy integrand in imaginary frequency appropriately.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Any frequencies will be converted to their absolute values times <code>1im</code>. Frequencies are not allowed to be exactly zero.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This computes the integrand <span>$\ln(\det(\mathbb{T}_{\infty} \mathbb{T}^{-1}))$</span> at specified imaginary frequencies, without doing any integration or Matsubara summation. This is typically a negative dimensionless quantity, and no factors of <span>$2\pi$</span> or <span>$\hbar$</span> are included.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This function can be embarrassingly parallelized over frequency and wavevector. However, the integrand at each frequency and wavevector is calculated for every transformation, as this maximizes the efficiency of the program by virtue of reusing quantities independent of geometric transformations.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The recommended way to do frequency integration or Matsubara summation is to supply a list of frequencies (typically not too many), and then interpolate the integrand to do integration or Matsubara summation after the fact.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/vdWenergy.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="vdWenergy_general" href="#vdWenergy_general"><code>vdWenergy_general</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vdWenergy_general(outfilename, myAllMolData, myTransData, myPeriodicData, Genvstr,
                  nonretarded, freqklist)</code></pre><p>Compute the actual vdW energy integrand and print it to <code>outfilename</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/vdWenergy.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="constructMolalphaealphainv!" href="#constructMolalphaealphainv!"><code>constructMolalphaealphainv!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">constructMolalphaealphainv!(myMolData::OneMol{FT},
                            myPeriodicData::PeriodicData{FT},
                            freq::Union{FT, Complex{FT}},
                            k::Array{FT, 1}=zeros(FT, 3)) where FT&lt;:AbstractFloat</code></pre><p>Construct the product of the electronic susceptibility with the full inverse molecular susceptibility <code>myMolData.alphainv</code> in-place at frequency <code>freq</code> and wavevector <code>k</code>, the latter of which must be a 3-element real vector. With phonons, <code>myMolData.alphainv</code> will be a matrix, the vector of atomic polarizabilities <code>myMolData.alpha0</code> will depend on the elements of <code>myMolData.alphainv</code>, and <code>myMolData.alphae</code> will be independent of these two. Without phonons, all three will be simply related to each other. This is more efficient than calling <code>constructMolAlpha!</code> and then performing a <code>broadcast</code> multiplication involving <code>myMolData.alphae</code> multiplying the rows of <code>myMolData.alphainv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/vdWenergy.jl#L196-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="constructMolalphaeGvacinf!" href="#constructMolalphaeGvacinf!"><code>constructMolalphaeGvacinf!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">constructMolalphaeGvacinf!(myMolData::OneMol{FT},
                           myPeriodicData::PeriodicData{FT},
                           currfreqG::Union{FT, Complex{FT}},
                           currk::Array{FT, 1}=zeros(FT, 3)) where FT&lt;:AbstractFloat</code></pre><p>Assemble the Green&#39;s function interaction matrix of a molecule in vacuum <code>myMolData.GvacGGinf</code>, then multiplies on the left by its electronic polarizabilities in-place, at frequency <code>currfreqG</code> and wavevector <code>currk</code> passing <code>myMolData</code> and <code>myPeriodicData</code> to the subsidiary functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/vdWenergy.jl#L281-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="mulalphaeGBlock!" href="#mulalphaeGBlock!"><code>mulalphaeGBlock!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mulalphaeGBlock!(A::AbstractArray{Complex{FT}, 2},
                 myAllMolData::MolSystem{&lt;:OneMol{FT}},
                 nn1::Integer, startidx1::Integer,
                 startidx2::Integer,
                 endidx2::Integer) where FT&lt;:AbstractFloat</code></pre><p>Assuming <code>A</code> represents a Green&#39;s function interaction matrix, multiply its block <code>A[startidx1-1+3*myAllMolData.numatomslist[nn1], startidx2:endidx2]</code> on the left by the electronic polarizabilities of molecule <code>nn1</code> from <code>myAllMolData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/vdWenergy.jl#L304-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="integrandvac" href="#integrandvac"><code>integrandvac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">integrandvac(myAllMolData::MolSystem{&lt;:OneMol{FT}},
             integrandvaclist::Array{FT, 1}) where FT&lt;:AbstractFloat</code></pre><p>Populate the list of vacuum contributions to the vdW integrand <code>integrandvaclist</code> with contributions from duplicate molecules where they exist, then return the sum yielding the total contribution to the integrand in vacuum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/vdWenergy.jl#L359-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="assemblealphaeTinvDiagBlock!" href="#assemblealphaeTinvDiagBlock!"><code>assemblealphaeTinvDiagBlock!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assemblealphaeTinvDiagBlock!(totalalphaeTinvmat::SharedArray{Complex{FT}, 2},
                             myAllMolData::MolSystem{&lt;:OneMol{FT}},
                             myTransData::TransData{FT}, nn2::Integer,
                             currmolind2::Integer, startidx2::Integer,
                             tt::Integer, myPeriodicData::PeriodicData{FT},
                             GFSCAGG!::Function,
                             currfreqG::Union{FT, Complex{FT}},
                             currk::Array{FT, 1}=zeros(FT, 3)) where FT&lt;:AbstractFloat</code></pre><p>Assemble the molecular diagonal block of the scattering Green&#39;s function interaction matrix of molecule <code>nn2</code> (whose unique molecular index <code>currmolind2</code> is precomputed and passed as an argument) at frequency <code>currfreqG</code> and wavevector <code>currk</code> using <code>GFSCAGG!</code>, multiply on the left by the electronic polarizabilities, then add the vacuum contribution which has already been computed as the electronic polarizabilities multiplied by the inverse T-operator of molecule <code>nn2</code>, performing any required matrix rotations corresponding to transformation <code>tt</code> for molecule <code>nn2</code>, and stamp that into <code>totalalphaeTinvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]</code>. Finally, undo any rotation corresponding to transformation <code>tt</code> in the inverse T-operator of molecule <code>nn2</code> for reuse with future transformations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/vdWenergy.jl#L384-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="assemblealphaeTinvOffDiagBlock!" href="#assemblealphaeTinvOffDiagBlock!"><code>assemblealphaeTinvOffDiagBlock!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assemblealphaeTinvOffDiagBlock!(totalalphaeTinvmat::SharedArray{Complex{FT}, 2},
                                myAllMolData::MolSystem{&lt;:OneMol{FT}},
                                myTransData::TransData{FT},
                                nn1::Integer, nn2::Integer,
                                startidx1::Integer,
                                startidx2::Integer,
                                myPeriodicData::PeriodicData{FT},
                                GFSCAGG!::Function,
                                currfreqG::Union{FT, Complex{FT}},
                                currk::Array{FT, 1}=zeros(FT, 3)) where FT&lt;:AbstractFloat</code></pre><p>Assemble the molecular off-diagonal block of the scattering Green&#39;s function interaction matrix of molecules <code>nn2</code> as the source and <code>nn1</code> as the field (whose respective unique molecular indices <code>currmolind1</code> and <code>currmolind2</code> are precomputed and passed as arguments) at frequency <code>currfreqG</code> and wavevector <code>currk</code> using <code>GFSCAGG!</code>, multiply on the left by the electronic polarizabilities, add the vacuum contribution, and stamp the negative of that into <code>totalalphaeTinvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]</code>. Do the same for the adjoint, swapping <code>nn2</code> and <code>nn1</code> without performing further Green&#39;s function computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/psv2/AARMBEM.jl/blob/8c307fb6270aa3dd85abb2cfb484c03928df3b2b/src/vdWenergy.jl#L439-L462">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="transdata.html">« Transformation data structures and methods</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 27 May 2020 15:53">Wednesday 27 May 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
