var documenterSearchIndex = {"docs":
[{"location":"api/vdWRHT.html#vdW-interactions-and-thermal-radiation-functions-1","page":"vdW interactions and thermal radiation functions","title":"vdW interactions and thermal radiation functions","text":"","category":"section"},{"location":"api/vdWRHT.html#Thermal-radiation-1","page":"vdW interactions and thermal radiation functions","title":"Thermal radiation","text":"","category":"section"},{"location":"api/vdWRHT.html#","page":"vdW interactions and thermal radiation functions","title":"vdW interactions and thermal radiation functions","text":"heattransfer\nheattransfer_general\nassemblePhimn!\nassembleTinvGenvDiagBlock!\nassembleTinvGenvOffDiagBlock!","category":"page"},{"location":"api/vdWRHT.html#heattransfer","page":"vdW interactions and thermal radiation functions","title":"heattransfer","text":"heattransfer(myARGS)\n\nExtract command-line arguments for computing the radiative heat transfer among a collection of molecules, then compute the radiative heat transfer appropriately.\n\nnote: Note\nAny frequencies will be converted to their absolute values. Frequencies are not allowed to be exactly zero.\n\nnote: Note\nThis computes the integrand operatornameTr(operatornameasym(mathbbV_m^-1) mathbbP_m mathbbT^dagger operatornameasym(mathbbP_n mathbbG^mathrmenv) mathbbTmathbbP_m) at specified real frequencies, without doing any integration. This includes neither numerical prefactors outside of the trace, nor the Planck function.\n\ntip: Tip\nThis function can be embarrassingly parallelized over frequency and wavevector. However, the integrand at each frequency and wavevector is calculated for every transformation, as this maximizes the efficiency of the program by virtue of reusing quantities independent of geometric transformations.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#heattransfer_general","page":"vdW interactions and thermal radiation functions","title":"heattransfer_general","text":"heattransfer_general(outfilename, myAllMolData, myTransData, myPeriodicData, Genvstr,\n                     nonretarded, freqklist)\n\nCompute the actual radiative heat transfer integrand and print it to outfilename.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#assemblePhimn!","page":"vdW interactions and thermal radiation functions","title":"assemblePhimn!","text":"assemblePhimn!(Phimn::Array{FT, 2},\n               myAllMolData::MolSystem{OneMol_WithPhonons{FT}},\n               myPeriodicData::PeriodicData{FT},\n               totalTmat::SharedArray{Complex{FT}, 2},\n               totalGenvmat::SharedArray{Complex{FT}, 2})\n\nAssemble the matrix Phimn, whose elements Phimn[nn1, nn2] represent the energy transfer from molecule nn1 to molecule nn2, computed from trace expressions involving the matrices totalTmat and totalGenvmat, in-place. If there is no spatial periodicity, Phimn should be symmetric. If there is spatial periodicity, the transpose of Phimn at wavevector veck is the equivalent of computing Phimn at -veck. This assumes the presence of phonons.\n\n\n\n\n\nassemblePhimn!(Phimn::Array{FT, 2},\n               myAllMolData::MolSystem{OneMol_NoPhonons{FT}},\n               myPeriodicData::PeriodicData{FT},\n               totalTmat::SharedArray{Complex{FT}, 2},\n               totalGenvmat::SharedArray{Complex{FT}, 2})\n\nAssemble the matrix Phimn, whose elements Phimn[nn1, nn2] represent the energy transfer from molecule nn1 to molecule nn2, computed from trace expressions involving the matrices totalTmat and totalGenvmat, in-place. If there is no spatial periodicity, Phimn should be symmetric. If there is spatial periodicity, the transpose of Phimn at wavevector veck is the equivalent of computing Phimn at -veck. This assumes the absence of phonons.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#assembleTinvGenvDiagBlock!","page":"vdW interactions and thermal radiation functions","title":"assembleTinvGenvDiagBlock!","text":"assembleTinvGenvDiagBlock!(totalTinvmat::SharedArray{Complex{FT}, 2},\n                           totalGenvmat::SharedArray{Complex{FT}, 2},\n                           myAllMolData::MolSystem{OneMol_WithPhonons{FT}},\n                           myTransData::TransData{FT}, nn2::Integer,\n                           currmolind2::Integer, startidx2::Integer,\n                           tt::Integer, myPeriodicData::PeriodicData{FT},\n                           GFSCAGG!::Function,\n                           currfreqG::Union{FT, Complex{FT}},\n                           currk::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nAssemble the molecular diagonal block of the scattering Green's function interaction matrix of molecule nn2 (whose unique molecular index currmolind2 is precomputed and passed as an argument) at frequency currfreqG and wavevector currk using GFSCAGG!, then add the vacuum contribution of molecule nn2, performing any required matrix rotations corresponding to transformation tt for molecule nn2. Stamp that added to coincident contributions into totalGenvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])], or that (without coincident contributions) subtracted from the inverse molecular susceptibility into totalTinvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]. Finally, undo any rotation corresponding to transformation tt in the inverse T-operator of molecule nn2 for reuse with future transformations. This assumes the presence of phonons.\n\n\n\n\n\nassembleTinvGenvDiagBlock!(totalTinvmat::SharedArray{Complex{FT}, 2},\n                           totalGenvmat::SharedArray{Complex{FT}, 2},\n                           myAllMolData::MolSystem{OneMol_NoPhonons{FT}},\n                           myTransData::TransData{FT}, nn2::Integer,\n                           currmolind2::Integer,\n                           startidx2::Integer,\n                           tt::Integer, myPeriodicData::PeriodicData{FT},\n                           GFSCAGG!::Function,\n                           currfreqG::Union{FT, Complex{FT}},\n                           currk::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nAssemble the molecular diagonal block of the scattering Green's function interaction matrix of molecule nn2 (whose unique molecular index currmolind2 is precomputed and passed as an argument) at frequency currfreqG and wavevector currk using GFSCAGG!, then add the vacuum contribution of molecule nn2, performing any required matrix rotations corresponding to transformation tt for molecule nn2. Stamp that added to coincident contributions into totalGenvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])], or that (without coincident contributions) subtracted from the inverse molecular susceptibility into totalTinvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]. Finally, undo any rotation corresponding to transformation tt in the inverse T-operator of molecule nn2 for reuse with future transformations. This assumes the absence of phonons.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#assembleTinvGenvOffDiagBlock!","page":"vdW interactions and thermal radiation functions","title":"assembleTinvGenvOffDiagBlock!","text":"assembleTinvGenvOffDiagBlock!(totalTinvmat::SharedArray{Complex{FT}, 2},\n                              totalGenvTinvmat::SharedArray{Complex{FT}, 2},\n                              myAllMolData::MolSystem{<:OneMol{FT}},\n                              myTransData::TransData{FT},\n                              nn1::Integer, nn2::Integer,\n                              startidx1::Integer,\n                              startidx2::Integer,\n                              myPeriodicData::PeriodicData{FT},\n                              GFSCAGG!::Function,\n                              currfreqG::Union{FT, Complex{FT}},\n                              currk::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nAssemble the molecular off-diagonal block of the scattering Green's function interaction matrix of molecules nn2 as the source and nn1 as the field (whose respective unique molecular indices currmolind1 and currmolind2 are precomputed and passed as arguments) at frequency currfreqG and wavevector currk using GFSCAGG!, multiply on the left by the electronic polarizabilities, add the vacuum contribution, and stamp that into totalGenvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])] and its negative into totalTinvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]. If there is no spatial periodicity, do the same for the (unconjugated) transpose, swapping nn2 and nn1 without performing further Green's function computations.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#vdW-interactions-1","page":"vdW interactions and thermal radiation functions","title":"vdW interactions","text":"","category":"section"},{"location":"api/vdWRHT.html#","page":"vdW interactions and thermal radiation functions","title":"vdW interactions and thermal radiation functions","text":"vdWenergy\nvdWenergy_general\nconstructMolalphaealphainv!\nconstructMolalphaeGvacinf!\nmulalphaeGBlock!\nintegrandvac\nassemblealphaeTinvDiagBlock!\nassemblealphaeTinvOffDiagBlock!","category":"page"},{"location":"api/vdWRHT.html#vdWenergy","page":"vdW interactions and thermal radiation functions","title":"vdWenergy","text":"vdWenergy(myARGS)\n\nExtract command-line arguments for computing the vdW interaction energy among a collection of molecules, then compute the vdW energy integrand in imaginary frequency appropriately.\n\nnote: Note\nAny frequencies will be converted to their absolute values times 1im. Frequencies are not allowed to be exactly zero.\n\nnote: Note\nThis computes the integrand ln(det(mathbbT_infty mathbbT^-1)) at specified imaginary frequencies, without doing any integration or Matsubara summation. This is typically a negative dimensionless quantity, and no factors of 2pi or hbar are included.\n\ntip: Tip\nThis function can be embarrassingly parallelized over frequency and wavevector. However, the integrand at each frequency and wavevector is calculated for every transformation, as this maximizes the efficiency of the program by virtue of reusing quantities independent of geometric transformations.\n\ntip: Tip\nThe recommended way to do frequency integration or Matsubara summation is to supply a list of frequencies (typically not too many), and then interpolate the integrand to do integration or Matsubara summation after the fact.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#vdWenergy_general","page":"vdW interactions and thermal radiation functions","title":"vdWenergy_general","text":"vdWenergy_general(outfilename, myAllMolData, myTransData, myPeriodicData, Genvstr,\n                  nonretarded, freqklist)\n\nCompute the actual vdW energy integrand and print it to outfilename.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#constructMolalphaealphainv!","page":"vdW interactions and thermal radiation functions","title":"constructMolalphaealphainv!","text":"constructMolalphaealphainv!(myMolData::OneMol{FT},\n                            myPeriodicData::PeriodicData{FT},\n                            freq::Union{FT, Complex{FT}},\n                            k::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nConstruct the product of the electronic susceptibility with the full inverse molecular susceptibility myMolData.alphainv in-place at frequency freq and wavevector k, the latter of which must be a 3-element real vector. With phonons, myMolData.alphainv will be a matrix, the vector of atomic polarizabilities myMolData.alpha0 will depend on the elements of myMolData.alphainv, and myMolData.alphae will be independent of these two. Without phonons, all three will be simply related to each other. This is more efficient than calling constructMolAlpha! and then performing a broadcast multiplication involving myMolData.alphae multiplying the rows of myMolData.alphainv.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#constructMolalphaeGvacinf!","page":"vdW interactions and thermal radiation functions","title":"constructMolalphaeGvacinf!","text":"constructMolalphaeGvacinf!(myMolData::OneMol{FT},\n                           myPeriodicData::PeriodicData{FT},\n                           currfreqG::Union{FT, Complex{FT}},\n                           currk::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nAssemble the Green's function interaction matrix of a molecule in vacuum myMolData.GvacGGinf, then multiplies on the left by its electronic polarizabilities in-place, at frequency currfreqG and wavevector currk passing myMolData and myPeriodicData to the subsidiary functions.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#mulalphaeGBlock!","page":"vdW interactions and thermal radiation functions","title":"mulalphaeGBlock!","text":"mulalphaeGBlock!(A::AbstractArray{Complex{FT}, 2},\n                 myAllMolData::MolSystem{<:OneMol{FT}},\n                 nn1::Integer, startidx1::Integer,\n                 startidx2::Integer,\n                 endidx2::Integer) where FT<:AbstractFloat\n\nAssuming A represents a Green's function interaction matrix, multiply its block A[startidx1-1+3*myAllMolData.numatomslist[nn1], startidx2:endidx2] on the left by the electronic polarizabilities of molecule nn1 from myAllMolData.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#integrandvac","page":"vdW interactions and thermal radiation functions","title":"integrandvac","text":"integrandvac(myAllMolData::MolSystem{<:OneMol{FT}},\n             integrandvaclist::Array{FT, 1}) where FT<:AbstractFloat\n\nPopulate the list of vacuum contributions to the vdW integrand integrandvaclist with contributions from duplicate molecules where they exist, then return the sum yielding the total contribution to the integrand in vacuum.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#assemblealphaeTinvDiagBlock!","page":"vdW interactions and thermal radiation functions","title":"assemblealphaeTinvDiagBlock!","text":"assemblealphaeTinvDiagBlock!(totalalphaeTinvmat::SharedArray{Complex{FT}, 2},\n                             myAllMolData::MolSystem{<:OneMol{FT}},\n                             myTransData::TransData{FT}, nn2::Integer,\n                             currmolind2::Integer, startidx2::Integer,\n                             tt::Integer, myPeriodicData::PeriodicData{FT},\n                             GFSCAGG!::Function,\n                             currfreqG::Union{FT, Complex{FT}},\n                             currk::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nAssemble the molecular diagonal block of the scattering Green's function interaction matrix of molecule nn2 (whose unique molecular index currmolind2 is precomputed and passed as an argument) at frequency currfreqG and wavevector currk using GFSCAGG!, multiply on the left by the electronic polarizabilities, then add the vacuum contribution which has already been computed as the electronic polarizabilities multiplied by the inverse T-operator of molecule nn2, performing any required matrix rotations corresponding to transformation tt for molecule nn2, and stamp that into totalalphaeTinvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]. Finally, undo any rotation corresponding to transformation tt in the inverse T-operator of molecule nn2 for reuse with future transformations.\n\n\n\n\n\n","category":"function"},{"location":"api/vdWRHT.html#assemblealphaeTinvOffDiagBlock!","page":"vdW interactions and thermal radiation functions","title":"assemblealphaeTinvOffDiagBlock!","text":"assemblealphaeTinvOffDiagBlock!(totalalphaeTinvmat::SharedArray{Complex{FT}, 2},\n                                myAllMolData::MolSystem{<:OneMol{FT}},\n                                myTransData::TransData{FT},\n                                nn1::Integer, nn2::Integer,\n                                startidx1::Integer,\n                                startidx2::Integer,\n                                myPeriodicData::PeriodicData{FT},\n                                GFSCAGG!::Function,\n                                currfreqG::Union{FT, Complex{FT}},\n                                currk::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nAssemble the molecular off-diagonal block of the scattering Green's function interaction matrix of molecules nn2 as the source and nn1 as the field (whose respective unique molecular indices currmolind1 and currmolind2 are precomputed and passed as arguments) at frequency currfreqG and wavevector currk using GFSCAGG!, multiply on the left by the electronic polarizabilities, add the vacuum contribution, and stamp the negative of that into totalalphaeTinvmat[(startidx2-1).+(1:3*myAllMolData.numatomslist[nn2]), (startidx2-1).+(1:3*myAllMolData.numatomslist[nn2])]. Do the same for the adjoint, swapping nn2 and nn1 without performing further Green's function computations.\n\n\n\n\n\n","category":"function"},{"location":"api/CMDARGS.html#Command-line-arguments-1","page":"Command-line arguments","title":"Command-line arguments","text":"","category":"section"},{"location":"api/CMDARGS.html#","page":"Command-line arguments","title":"Command-line arguments","text":"readRequiredFilenameARG\nreadOptionalFilenameARG\nreadGenvstr\nreadOptionalBoolcondARG\nreadOptionalFloatType\nreadfreqlist!\nreadklist","category":"page"},{"location":"api/CMDARGS.html#readRequiredFilenameARG","page":"Command-line arguments","title":"readRequiredFilenameARG","text":"readRequiredFilenameARG(myARGS, currfilename, callingfunc)\n\nRead from the list of command-line arguments myARGS the file name prefixed by currfilename and an equals sign. Throw an error (using callingfunc to emphasize where it is needed) if that argument is missing.\n\nSee also: readOptionalFilenameARG, readGenvstr, readOptionalBoolcondARG, readOptionalFloatType, readfreqlist!, readklist\n\n\n\n\n\n","category":"function"},{"location":"api/CMDARGS.html#readOptionalFilenameARG","page":"Command-line arguments","title":"readOptionalFilenameARG","text":"readOptionalFilenameARG(myARGS, currfilename)\n\nRead from the list of command-line arguments myARGS the file name prefixed by currfilename and an equals sign. Return a blank string if that argument is missing.\n\nSee also: readRequiredFilenameARG, readGenvstr, readOptionalBoolcondARG, readOptionalFloatType, readfreqlist!, readklist\n\n\n\n\n\n","category":"function"},{"location":"api/CMDARGS.html#readGenvstr","page":"Command-line arguments","title":"readGenvstr","text":"readGenvstr(myARGS)\n\nRead from the list of command-line arguments myARGS the environmental Green's function prefixed by \"Genv=\". Return \"PEC\" (representing a PEC plane) only if that is explicitly found, otherwise return \"VAC\" by default.\n\nSee also: readRequiredFilenameARG, readOptionalFilenameARG, readOptionalBoolcondARG, readOptionalFloatType, readfreqlist!, readklist\n\n\n\n\n\n","category":"function"},{"location":"api/CMDARGS.html#readOptionalBoolcondARG","page":"Command-line arguments","title":"readOptionalBoolcondARG","text":"readOptionalBoolcondARG(myARGS, currvarname, outfilename)\n\nRead from the list of command-line arguments myARGS optional boolean arguments labeled by currvarname, and modify outfilename as appropriate.\n\nSee also: readRequiredFilenameARG, readOptionalFilenameARG, readGenvstr, readOptionalFloatType, readfreqlist!, readklist\n\n\n\n\n\n","category":"function"},{"location":"api/CMDARGS.html#readOptionalFloatType","page":"Command-line arguments","title":"readOptionalFloatType","text":"readOptionalFloatType(myARGS)\n\nRead from the list of command-line arguments myARGS optional arguments labeling the floating-point type. Return Float64 by default if nothing else is found.\n\nSee also: readRequiredFilenameARG, readOptionalFilenameARG, readGenvstr, readOptionalBoolcondARG, readfreqlist!, readklist\n\n\n\n\n\n","category":"function"},{"location":"api/CMDARGS.html#readfreqlist!","page":"Command-line arguments","title":"readfreqlist!","text":"readfreqlist!(freqlist, myARGS, callingfunc)\n\nRead from the list of command-line arguments myARGS the list of frequencies, modifying freqlist \"in-place\" (actually appending as needed), and using the name callingfunc to be more informative when throwing errors.\n\nnote: Note\nAny frequencies will be converted to their absolute values. Frequencies are not allowed to be exactly zero.\n\nSee also: readRequiredFilenameARG, readOptionalFilenameARG, readGenvstr, readOptionalBoolcondARG, readOptionalFloatType, readklist\n\n\n\n\n\n","category":"function"},{"location":"api/CMDARGS.html#readklist","page":"Command-line arguments","title":"readklist","text":"readklist(myARGS, callingfunc, numdims)\n\nRead from the list of command-line arguments myARGS the list of Bloch wavevectors, returning zeros(FT, 1, 3) if numdims is zero.\n\nSee also: readRequiredFilenameARG, readOptionalFilenameARG, readGenvstr, readOptionalBoolcondARG, readOptionalFloatType, readfreqlist!\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#Transformation-data-structures-and-methods-1","page":"Transformation data structures and methods","title":"Transformation data structures and methods","text":"","category":"section"},{"location":"api/transdata.html#Generic-functions-1","page":"Transformation data structures and methods","title":"Generic functions","text":"","category":"section"},{"location":"api/transdata.html#","page":"Transformation data structures and methods","title":"Transformation data structures and methods","text":"The functions in this section may be useful outside of AARMBEM.jl, and can be used independently in any case.","category":"page"},{"location":"api/transdata.html#","page":"Transformation data structures and methods","title":"Transformation data structures and methods","text":"findCOM\ntranslateCOM!\ntranslateCOM\nrotatecoords!\nrotatecoords\nrotate3Nmat!\nrotate3Nmat\nmakeCOM0!\nmakeCOM0","category":"page"},{"location":"api/transdata.html#findCOM","page":"Transformation data structures and methods","title":"findCOM","text":"findCOM(pos0, startatom=1, endatom=size(pos0, 2))\n\nReturn the unweighted center of mass of a block pos0[:, startatom:endatom] of coordinates, where each column pos0[:, p] has 3 elements representing the Cartesian coordinates of a particle labeled p.\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#translateCOM!","page":"Transformation data structures and methods","title":"translateCOM!","text":"translateCOM!(pos0, dispCOM, startatom=1, endatom=size(pos0, 2))\n\nTranslate the block pos0[:, startatom:endatom] of coordinates in-place (overwriting it), where each column pos0[:, p] has 3 elements representing the Cartesian coordinates of a particle labeled p and dispCOM is a 3-element vector representing the displacement, such that for each p in the range, pos0[:, p] .+= dispCOM.\n\nSee also: translateCOM\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#translateCOM","page":"Transformation data structures and methods","title":"translateCOM","text":"translateCOM(pos0, dispCOM, startatom=1, endatom=size(pos0, 2))\n\nTranslate the block pos0[:, startatom:endatom] of coordinates not in-place, returning the result, where each column pos0[:, p] has 3 elements representing the Cartesian coordinates of a particle labeled p and dispCOM is a 3-element vector representing the displacement, such that for each p in the range, pos0[:, p] .+= dispCOM.\n\nSee also: translateCOM!\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#rotatecoords!","page":"Transformation data structures and methods","title":"rotatecoords!","text":"rotatecoords!(pos0, rotmat, startatom=1, endatom=size(pos0, 2))\n\nRotate the block pos0[:, startatom:endatom] of coordinates in-place (overwriting it), where each column pos0[:, p] has 3 elements representing the Cartesian coordinates of a particle labeled p and rotmat is a 3-by-3 matrix representing the (alibi) rotation, such that for each p in the range, pos0[:, p] .= rotmat * pos0[:, p].\n\nSee also: rotatecoords\n\nwarning: Warning\nThis function will not check whether rotmat is real and orthogonal. It is the responsibility of the caller to ensure that rotmat represents a physical rotation; otherwise, unexpected behavior could emerge.\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#rotatecoords","page":"Transformation data structures and methods","title":"rotatecoords","text":"rotatecoords(pos0, rotmat, startatom=1, endatom=size(pos0, 2))\n\nRotate the block pos0[:, startatom:endatom] of coordinates not in-place, returning the result, where each column pos0[:, p] has 3 elements representing the Cartesian coordinates of a particle labeled p and rotmat is a 3-by-3 matrix representing the rotation, such that for each p in the range, pos0[:, p] .= rotmat * pos0[:, p].\n\nwarning: Warning\nThis function will not check whether rotmat is real and orthogonal. It is the responsibility of the caller to ensure that rotmat represents a physical rotation; otherwise, unexpected behavior could emerge.\n\nSee also: rotatecoords!\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#rotate3Nmat!","page":"Transformation data structures and methods","title":"rotate3Nmat!","text":"rotate3Nmat!(A, rotmat, startatom=1, endatom=div(size(A, 2), 3))\n\nRotate the contents in the diagonal block of the complex matrix A[3*startatom-2:3*endatom, 3*startatom-2:3*endatom] by rotating each 3-by-3 block therein by the 3-by-3 real orthogonal (alibi) rotation matrix rotmat; this is done in-place, overwriting A.\n\nSee also: rotate3Nmat\n\nwarning: Warning\nThis function will not check whether rotmat is real and orthogonal. It is the responsibility of the caller to ensure that rotmat represents a physical rotation; otherwise, unexpected behavior could emerge.\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#rotate3Nmat","page":"Transformation data structures and methods","title":"rotate3Nmat","text":"rotate3Nmat(A, rotmat, startatom=1, endatom=div(size(A, 2), 3))\n\nRotate the contents in the diagonal block of the complex matrix A[3*startatom-2:3*endatom, 3*startatom-2:3*endatom] by rotating each 3-by-3 block therein by the 3-by-3 real orthogonal (alibi) rotation matrix rotmat; this is done not in-place, returning the result.\n\nSee also: rotate3Nmat!\n\nwarning: Warning\nThis function will not check whether rotmat is real and orthogonal. It is the responsibility of the caller to ensure that rotmat represents a physical rotation; otherwise, unexpected behavior could emerge.\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#makeCOM0!","page":"Transformation data structures and methods","title":"makeCOM0!","text":"makeCOM0!(pos0, startatom=1, endatom=size(pos0, 2))\n\nTranslate the block pos0[:, startatom:endatom] of coordinates in-place (overwriting it) to have a center of mass of 0, where each column pos0[:, p] has 3 elements representing the Cartesian coordinates of a particle labeled p.\n\nSee also: makeCOM0\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#makeCOM0","page":"Transformation data structures and methods","title":"makeCOM0","text":"makeCOM0(pos0, startatom=1, endatom=size(pos0, 2))\n\nTranslate the block pos0[:, startatom:endatom] of coordinates not in-place, returning the result, to have a center of mass of 0, where each column pos0[:, p] has 3 elements representing the Cartesian coordinates of a particle labeled p.\n\nSee also: makeCOM0!\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#Data-structures-and-associated-functions-1","page":"Transformation data structures and methods","title":"Data structures and associated functions","text":"","category":"section"},{"location":"api/transdata.html#","page":"Transformation data structures and methods","title":"Transformation data structures and methods","text":"TransData\nreadTransData\ninitializeAtomPos!\ntransformAtomPos!\nuntransformAtomPos!","category":"page"},{"location":"api/transdata.html#TransData","page":"Transformation data structures and methods","title":"TransData","text":"TransData{FT<:AbstractFloat}\n\nStore information relevant to the particular geometrical configuration, not intrinsic to molecules themselves, involving rigid geometrical transformations (translations and rotations); this depends on the number of molecules nummols from MolSystem{T<:OneMol{<:AbstractFloat}}.\n\nnumTrans is the number of transformations t (an integer).\n\ntransArray is a 3*nummols-by-numTrans real array where each 3-element vector transArray[3*nn-2:3*nn, tt] is the center-of-mass translation vector (relative to the baseline) for molecule nn in transformation labeled tt.\n\nrotArray is a 3*nummols-by-3*numTrans real array where each 3-by-3 block rotArray[3*nn-2:3*nn, 3*tt-2:3*tt] is the center-of-mass rotation matrix (relative to the baseline) for molecule nn in transformation labeled tt.\n\ntransLabels is a numTrans-element vector of strings labeling each transformation tt.\n\nchangedFromBefore is an nummols-by-numTrans BitArray such that changedFromBefore[nn, tt] is true if molecule nn is transformed in transformation tt relative to transformation tt - 1, false otherwise.\n\nallAtomPos is the horizontal concatenation of atomic coordinates (initially unmodified, later modified, by transformations) across all molecules.\n\nbaselineTrans is a 3*nummols-element real vector where each 3-element vector baselineTrans[3*nn-2:3*nn] is the baseline center of mass coordinate for molecule nn.\n\nbaselineRot is a 3*nummols-by-3 real matrix where each 3-by-3 block baselineRot[3*nn-2:3*nn,:] is the baseline center of mass rotation matrix for the orientation of molecule nn. Note that for both baselineRot and rotArray, each 3-by-3 Cartesian rotation matrix is given as the transpose of the overall matrix Z_1 Y_2 X_3 in the Tait–Bryan convention, where angle 1 is psi, angle 2 is theta, and angle 3 is varphi. In particular, each rotation matrix is the product R_z(-psi) R_y(-theta) R_x(-varphi), where R_i(alpha) is a standard alibi rotation about Cartesian axis vece_i; for example, R_z(pi2) multiplied on the left of the 3-element column (1 0 0)^top yields (0 1 0)^top, and on the left of (0 1 0)^top yields (-1 0 0)^top. Note also that in the file with name translistfilename, the angles for each baseline orientation as well as each transformation beyond that must be listed in the order phi then theta then psi, in DEGREES.\n\n\n\n\n\n","category":"type"},{"location":"api/transdata.html#readTransData","page":"Transformation data structures and methods","title":"readTransData","text":"readTransData(myMolData::MolSystem{<:OneMol{FT}},\n              translistfilename::AbstractString=\"\") where FT<:AbstractFloat\n\nConstruct TransData from existing molecular data myMolData and a file of name translistfilename containing information about geometric transformations; if no file is specified, produce a default set of transformations (no displacements or rotations at all).\n\nSee also: MolSystem{<:OneMol{FT}}\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#initializeAtomPos!","page":"Transformation data structures and methods","title":"initializeAtomPos!","text":"initializeAtomPos!(myTransData::TransData{FT},\n                   myMolData::MolSystem{<:OneMol{FT}}) where FT<:AbstractFloat\n\nInitialize atomic coordinates across all molecules by first shifting coordinates of all molecules to have centers of mass of 0, then rotating all molecular coordinates according to baseline orientations of each, then translating to desired baseline centers of mass, modifying myTransData in-place.\n\nSee also: transformAtomPos!, untransformAtomPos!\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#transformAtomPos!","page":"Transformation data structures and methods","title":"transformAtomPos!","text":"transformAtomPos!(myTransData::TransData{FT},\n                  myMolData::MolSystem{<:OneMol{FT}},\n                  tt::Integer) where FT<:AbstractFloat\n\nTransform atomic coordinates across all molecules by first shifting coordinates of all molecules to have centers of mass of 0, then rotating all molecular coordinates according to orientations corresponding to transformation tt relative to the baseline, then translating to desired centers of mass corresponding to transformation tt relative to the baseline, modifying myTransData in-place.\n\nSee also: initializeAtomPos!, untransformAtomPos!\n\n\n\n\n\n","category":"function"},{"location":"api/transdata.html#untransformAtomPos!","page":"Transformation data structures and methods","title":"untransformAtomPos!","text":"untransformAtomPos!(myTransData::TransData{FT},\n                    myMolData::MolSystem{<:OneMol{FT}},\n                    tt::Integer) where FT<:AbstractFloat\n\nUndo transformation of atomic coordinates across all molecules by first shifting coordinates of all molecules to have centers of mass of 0, then rotating all molecular coordinates according to orientations corresponding to the opposites of transformation tt to return to the baseline, then translating back to the desired baseline centers of mass, modifying myTransData in-place.\n\nSee also: initializeAtomPos!, transformAtomPos!\n\n\n\n\n\n","category":"function"},{"location":"examples/2grapheneVAC.html#Two-identical-parallel-graphene-sheets-(vacuum)-1","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"","category":"section"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"This page links to examples of input files needed to compute vdW interaction free energies and thermal radiation powers in a system of Bloch periodic molecular bodies. The particular system under consideration is of two parallel graphene sheets in vacuum at a separation z from each other (with no horizontal offset); each sheet is identical, and a 39mathrmnm times 34mathrmnm rectangular unit cell in the xy-plane (i.e. not the hexagonal primitive unit cell) is used.","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"note: Note\nThe Ewald summation parameters have been hardcoded to give good convergence for graphene, as in this example.","category":"page"},{"location":"examples/2grapheneVAC.html#Molecular-configuration-files-1","page":"Two identical parallel graphene sheets (vacuum)","title":"Molecular configuration files","text":"","category":"section"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"The input data files are as follows.","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"B_mathrme for graphene: graphene3p9nmby3p4nmunitcellBe.txt","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"B_mathrmI for graphene: graphene3p9nmby3p4nmunitcellBI.txt","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"K_mathrme for graphene: graphene3p9nmby3p4nmunitcellKe.txt","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"K_mathrmI for graphene: graphene3p9nmby3p4nmunitcellKI.txt","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"M_mathrme for graphene: graphene3p9nmby3p4nmunitcellMe.txt","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"M_mathrmI for graphene: graphene3p9nmby3p4nmunitcellMI.txt","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"Q_mathrme for graphene: graphene3p9nmby3p4nmunitcellQe.txt","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"Atomic coordinates vecr_p for graphene: graphene3p9nmby3p4nmunitcellxyz.txt","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"Overall configuration file: 2graphene3p9nmby3p4nmVACconfig_periodic.txt","category":"page"},{"location":"examples/2grapheneVAC.html#Transformation-file-1","page":"Two identical parallel graphene sheets (vacuum)","title":"Transformation file","text":"","category":"section"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"Transformation file: 2graphene3p9nmby3p4nmVACtrans_periodic.txt","category":"page"},{"location":"examples/2grapheneVAC.html#Bloch-periodicity-file-1","page":"Two identical parallel graphene sheets (vacuum)","title":"Bloch periodicity file","text":"","category":"section"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"Bloch periodicity file: 1graphene3p9nmby3p4nmlatticevecs.txt","category":"page"},{"location":"examples/2grapheneVAC.html#Frequency-and-Bloch-wavevector-files-1","page":"Two identical parallel graphene sheets (vacuum)","title":"Frequency and Bloch wavevector files","text":"","category":"section"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"Frequency file: freq31.txt Bloch wavevector file: graphene3p9nmby3p4nmunitcellklist1.txt","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"(Many more frequencies must be used to replicate the output for vdW interaction free energies and thermal radiation powers: these can in principle be extracted from the corresponding output files themselves, but this is hampered in practice by the truncation of the output files in this example for space reasons. For clarity, in the example output files used, for vdW interactions, the input frequencies omega = mathrmiw used were w_n = 10^10 + (n - 1)10mathrmrads for n in 1 2 ldots 81, while for thermal radiation, the input frequencies omega = w used were w_n = n times 10^12mathrmrads for n in 1 2 ldots 500. Similarly, many more Bloch wavevectors must be used. These have been sampled in a less regular manner than the frequencies but are sampled in the same way for both vdW interactions and thermal radiation, though the rotational and mirror symmetries of the rectangular unit cell mean that only k_x geq 0 and k_y geq 0 need to be sampled.)","category":"page"},{"location":"examples/2grapheneVAC.html#Output-files-1","page":"Two identical parallel graphene sheets (vacuum)","title":"Output files","text":"","category":"section"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"vdW interaction free energies: 2graphene3p9nmby3p4nmVACvdW_periodic.out","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"Thermal radiation powers: 2graphene3p9nmby3p4nmVACheat_periodic.out","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"note: Note\nThe ordering of output lines may vary from one run to another.","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"note: Note\nThese files have been abbreviated to the first 100000 lines for space reasons when presenting these examples.","category":"page"},{"location":"examples/2grapheneVAC.html#Standard-commands-to-yield-these-output-files-1","page":"Two identical parallel graphene sheets (vacuum)","title":"Standard commands to yield these output files","text":"","category":"section"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"vdW interaction free energies:","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"julia -p 1 AARMBEM_vdW.jl mollistfilename=2graphene3p9nmby3p4nmVACconfig_periodic.txt outfilename=2graphene3p9nmby3p4nmVACvdW_periodic.out translistfilename=2graphene3p9nmby3p4nmVACtrans_periodic.txt periodicfilename=1graphene3p9nmby3p4nmlatticevecs.txt freqlistfilename=freq31.txt klistfilename=graphene3p9nmby3p4nmunitcellklist1.txt Genv=VAC","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"Thermal radiation powers:","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"julia -p 1 AARMBEM_heat.jl mollistfilename=2graphene3p9nmby3p4nmVACconfig_periodic.txt outfilename=2graphene3p9nmby3p4nmVACheat_periodic.out translistfilename=2graphene3p9nmby3p4nmVACtrans_periodic.txt periodicfilename=1graphene3p9nmby3p4nmlatticevecs.txt freqlistfilename=freq31.txt klistfilename=graphene3p9nmby3p4nmunitcellklist1.txt Genv=VAC","category":"page"},{"location":"examples/2grapheneVAC.html#Other-possible-examples-for-commands-(not-exhaustive)-1","page":"Two identical parallel graphene sheets (vacuum)","title":"Other possible examples for commands (not exhaustive)","text":"","category":"section"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"Thermal radiation powers in the absence of EM retardation:","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"julia -p 1 AARMBEM_heat.jl mollistfilename=2graphene3p9nmby3p4nmVACconfig_periodic.txt outfilename=2graphene3p9nmby3p4nmVACheat_periodic.out translistfilename=2graphene3p9nmby3p4nmVACtrans_periodic.txt periodicfilename=1graphene3p9nmby3p4nmlatticevecs.txt freqlistfilename=freq31.txt klistfilename=graphene3p9nmby3p4nmunitcellklist1.txt Genv=VAC nonretarded","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"The output file name will actually be nonretarded_2graphene3p9nmby3p4nmVACheat_periodic.out.","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"vdW interaction free energies in the absence of phonons:","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"julia -p 1 AARMBEM_vdW.jl mollistfilename=2graphene3p9nmby3p4nmVACconfig_periodic.txt outfilename=2graphene3p9nmby3p4nmVACvdW_periodic.out translistfilename=2graphene3p9nmby3p4nmVACtrans_periodic.txt periodicfilename=1graphene3p9nmby3p4nmlatticevecs.txt freqlistfilename=freq31.txt klistfilename=graphene3p9nmby3p4nmunitcellklist1.txt Genv=VAC nophonons","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"The output file name will actually be nophonons_2graphene3p9nmby3p4nmVACvdW_periodic.out.","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"vdW interaction free energies in the absence of phonons or EM retardation:","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"julia -p 1 AARMBEM_vdW.jl mollistfilename=2graphene3p9nmby3p4nmVACconfig_periodic.txt outfilename=2graphene3p9nmby3p4nmVACvdW_periodic.out translistfilename=2graphene3p9nmby3p4nmVACtrans_periodic.txt periodicfilename=1graphene3p9nmby3p4nmlatticevecs.txt freqlistfilename=freq31.txt klistfilename=graphene3p9nmby3p4nmunitcellklist1.txt Genv=VAC nophonons nonretarded","category":"page"},{"location":"examples/2grapheneVAC.html#","page":"Two identical parallel graphene sheets (vacuum)","title":"Two identical parallel graphene sheets (vacuum)","text":"The output file name will actually be nonretarded_nophonons_2graphene3p9nmby3p4nmVACvdW_periodic.out.","category":"page"},{"location":"theory/theoreticalbackground.html#Theoretical-background-1","page":"Theory","title":"Theoretical background","text":"","category":"section"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"This page explains the theoretical background for the RMB framework, and for its implementation in AARMBEM.jl. After explaining notation, the main formulas and assumptions are summarized, and then the implementation in AARMBEM.jl is explained; more details may be found in work by Venkataram et al [VenkataramARXIV2020].","category":"page"},{"location":"theory/theoreticalbackground.html#Notation-1","page":"Theory","title":"Notation","text":"","category":"section"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"The following is a table of common notation used throughout this site, and particularly this page.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"Notation Meaning Comments\nvertvecvrangle v_i (vecx) semiclassical field, not second-quantized state\nlangle vecu vecv rangle sum_i int u_i^star (vecx) v_i (vecx)mathrmd^3 x basis-independent conjugated inner product\nmathbbA A_ij(vecx vecx) integral kernel: vertvecvrangle = mathbbAvertvecurangle means v_i(vecx) = sum_j int A_ij(vecx vecx)u_j(vecx)mathrmd^3 x\nmathbbI delta_ij delta^3(vecx - vecx) identity operator\nmathbbP_n delta_ij delta^3(vecx - vecx) Theta(vecx in V_n) projection onto material DOFs of body n\nmathbbA^dagger (mathbbA^dagger)_ij(vecx vecx) = A^star_ji(vecx vecx) Hermitian adjoint: basis-independent, langle vecu mathbbA^dagger vecv rangle = langle mathbbA vecu vecv rangle\noperatornamesym(mathbbA) (mathbbA + mathbbA^dagger)2 Hermitian part for square operator\noperatornameasym(mathbbA) (mathbbA - mathbbA^dagger)(2mathrmi) anti-Hermitian part for square operator\nmathbbA^top (mathbbA^top)_ij(vecx vecx) = A_ji(vecx vecx) unconjugated transpose: basis-dependent\nmathbbA^star (mathbbA^star)_ij(vecx vecx) = A^star_ij(vecx vecx) complex conjugate: basis-dependent\noperatornameRe(mathbbA) (mathbbA + mathbbA^star)2 real part\noperatornameIm(mathbbA) (mathbbA - mathbbA^star)(2mathrmi) imaginary part\nmathbbAB sum_l int A_il(vecx vecx) B_lj(vecx vecx)mathrmd^3 x operator product, not commutative\noperatornameTrmathbbA sum_i int A_ii(vecx vecx)mathrmd^3 x trace, basis-independent","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"Note also that operators relevant to EM theory will commonly depend on the frequency omega as a parameter; this will generally be suppressed in the notation for brevity, and context will make clear whether the dependence is on real frequency omega versus imaginary frequency omega = mathrmixi. Furthermore, the Maxwell Green's function mathbbG is defined to satisfy nabla times (nabla times) - (omegac)^2 (mathbbI + mathbbV)mathbbG = (omegac)^2 mathbbI in the presence of a (possibly nonlocal, inhomogeneous, anisotropic) susceptibility mathbbV, so that the solution in vacuum (mathbbV to 0) is G^(0)_ij(vecx vecx) = partial_i partial_j + (omegac)^2 delta_ij(e^mathrmiomegavertvecx - vecxvertc(4pivertvecx - vecxvert)), and this reproduces the field due to a static point dipole in the electrostatic (c to infty) limit.","category":"page"},{"location":"theory/theoreticalbackground.html#Formulas-relevant-for-FED-1","page":"Theory","title":"Formulas relevant for FED","text":"","category":"section"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"AARMBEM.jl assumes that there exist N molecular bodies labeled n with susceptibilities mathbbV_n that are separable/distinct/disjoint from each other (i.e. there are no inherent nonlocal correlations between bodies); this separability means the total susceptibility of the system may be written as a sum mathbbV = sum_n = 1^N mathbbV_n. These interact in the presence of a macroscopic environment (which, for the implementation in AARMBEM.jl, may be vacuum or a PEC plane at z = 0) whose Maxwell Green's function is defined as mathbbG^mathrmmac; for convenience, the scattering Green's function will also be defined as mathbbG^mathrmsca = mathbbG^mathrmmac - mathbbG^(0) (and this vanishes in vacuum).","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"Given these definitions, the most important quantity for EM scattering in general, and for FED phenomena in turn, is the T-operator, defined as mathbbT = (mathbbV^-1 - mathbbG^mathrmmac)^-1 = (mathbbI - mathbbVmathbbG^mathrmmac)^-1 mathbbV. This describes EM scattering to all orders within and between all bodies involved. It can be defined in block matrix form as","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"mathbbT^-1 =\nbeginbmatrix\nmathbbV_1^-1 - mathbbG^mathrmmac_11  -mathbbG^mathrmmac_12  -mathbbG^mathrmmac_13  ldots \n-mathbbG^mathrmmac_21  mathbbV_2^-1 - mathbbG^mathrmmac_22  -mathbbG^mathrmmac_23  ldots \n-mathbbG^mathrmmac_31  -mathbbG^mathrmmac_32  mathbbV_3^-1 - mathbbG^mathrmmac_33  ldots \nvdots  vdots  vdots  ddots\nendbmatrix","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"where the blocks mathbbG^mathrmmac_mn = mathbbP_m mathbbG^mathrmmac mathbbP_n are the projections of mathbbG^mathrmmac onto the DOFs of the molecules m and n. Also relevant to vdW interactions in particular is the quantity mathbbT_infty, which is the evaluation of mathbbT when each molecular body is taken to be infinitely far away from every other molecular and macroscopic body (for which mathbbG^mathrmmac may be replaced by mathbbG^(0)).","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"In terms of this, the vdW interaction free energy at thermal equilibrium is defined for temperature T as","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"mathcalF(T) = k_mathrmB Tsum_l = 0^infty  f(mathrmixi_l)","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"in terms of the integrand f(mathrmixi) = ln(detmathbbT_infty mathbbT^-1) evaluated at the Matsubara frequencies xi_l = 2pi k_mathrmB Tlhbar, where the prime over the summation implies an additional prefactor of 12 for the contribution l = 0; at T = 0, this turns into the integral mathcalF(0) = mathcalE = hbarint_0^infty f(mathrmixi)fracmathrmdxi2pi.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"The thermal radiation power may generally be defined as","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"P = int_0^infty W(omega)fracmathrmdomega2pi","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"in terms of an appropriate function W(omega); it is assumed that each body n is at a certain temperature T_n, and that these are immersed in an environment of temperature T_mathrmenv (which, for the implementation in AARMBEM.jl, is also the temperature of the PEC plane if present). For total thermal emission from a specific body m, the function is defined as","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"W^(m) = sum_n = 1^N s_nm Pi(omega T_n) - Pi(omega\nT_mathrmenv)Phi^(m)_n","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"in terms of the sign function s_nm = 1 - 2delta_nm, while for net radiative heat transfer between bodies m and n, the function is defined as","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"W_m to n = Pi(omega T_m) - Pi(omega\nT_n)Phi^(m)_n","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"and both of these are defined in terms of the Planck function Pi(omega T) = hbaromega(e^hbaromega(k_mathrmB T) - 1) as well as the spectral function Phi^(m)_n (omega). This spectral function is defined as","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"Phi^(m)_n =\n-4operatornameTroperatornameasym(mathbbV_m^-1dagger)\nmathbbP_m mathbbT^dagger operatornameasym(mathbbP_n\nmathbbG^mathrmmac) mathbbT mathbbP_m","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"in terms of the aforementioned macroscopic Green's function and overall T-operators. Reciprocity means that it satisfies Phi^(m)_n (omega) = Phi^(n)_m (omega).","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"These formulas are fully general, and when all bodies are compact (i.e. have well-defined finite dimensions in all directions appropriate for the problem at hand), these formulas require no further analytical manipulation. When all bodies have commensurate discrete translational symmetries in d in 1 2 dimensions, it is most useful to perform these computations imposing Bloch periodic boundary conditions in a unit cell of general volume (which in 1 dimension is a length, or in 2 dimensions is an area) V_mathrmuc, and where Bloch wavevectors veck lie within the BZ. This means that we use as the vdW free energy integrand","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"f(mathrmixi) = int_mathrmBZ f(mathrmixi\nveck)fracV_mathrmucmathrmd^d k(2pi)^d","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"where f(mathrmixi veck) = ln(detmathbbT_infty mathbbT^-1) has all relevant operators evaluated at (mathrmixi veck); this will yield a vdW free energy per unit cell. Because (mathbbT(mathrmixi veck))^top = mathbbT(mathrmixi -veck) with a similar relation holding for mathbbT_infty, and the determinant is invariant with respect to transposition and for a product of operators is invariant with respect to their ordering, then f(mathrmixi veck) = f(mathrmixi -veck).  Similarly, we use as the thermal radiation power integrand","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"Phi^(m)_n (omega) = int_mathrmBZ Phi^(m)_n (omega\nveck)fracV_mathrmucmathrmd^d k(2pi)^d","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"where Phi^(m)_n(omega veck) = -4operatornameTroperatornameasym(mathbbV_m^-1dagger) mathbbP_m mathbbT^dagger operatornameasym(mathbbP_n mathbbG^mathrmmac) mathbbT mathbbP_m has all relevant operators evaluated at (omega veck); this will yield a thermal radiation power per unit cell. Because the various operators are reciprocal, satisfying (mathbbA(omega veck))^top = mathbbA(omega -veck), then Phi^(m)_n (omega veck) = Phi^(n)_m (omega -veck).","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"The following sections will discuss the details of the RMB framework in representing molecular polarization response functions to construct these operators in appropriate bases; these representations can be generalized to other EM scattering phenomena beyond FED phenomena, but the focus of AARMBEM.jl is on FED phenomena.","category":"page"},{"location":"theory/theoreticalbackground.html#RMB-representation-of-EM-scattering-operators-1","page":"Theory","title":"RMB representation of EM scattering operators","text":"","category":"section"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"For any of these quantities to be computed, these operators require representations as matrices. As the molecular bodies are assumed to be disjoint, the total susceptibility is block-diagonal in the basis of molecular bodies. Given this, each molecular susceptibility may be expanded generically in a certain basis. For bodies that have atom-scale feature sizes but highly delocalized electronic response, the basis functions should be correspondingly delocalized in real space. The RMB framework in principle allows for this, but the AARMBEM.jl code has not implemented this. Instead, the AARMBEM.jl code implements a set of basis functions appropriate for insulating or weakly conducting media. This is described as follows.","category":"page"},{"location":"theory/theoreticalbackground.html#Susceptibilities-1","page":"Theory","title":"Susceptibilities","text":"","category":"section"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"Appropriate for relatively localized electronic response, each molecular body has mapped onto itself a set of effective oscillator DOFs, specifically corresponding to one effective valence electronic oscillator and one effective screened nuclear oscillator for each atom. This means the susceptibility of each molecular body may be written as mathbbV_n = sum_piqj alpha_piqj vertvecf_piranglelanglevecf_qjvert, where the basis functions vertvecf_pirangle are chosen as appropriate localized functions, while the expansion coefficients alpha_piqj are the elements of a matrix alpha that are derived from oscillator equations of motion described as follows.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"For each atom p, the valence electronic oscillator has an effective mass m_mathrmep, charge (coupling it to long-range EM fields) q_mathrmep, damping coefficient b_mathrmep, and isotropic spring constant (coupling it to its corresponding screened nuclear oscillator) k_mathrmep, while the screened nuclear oscillator at position vecr_p does not couple directly to long-range EM fields due to screening by electrons but does have an effective mass m_mathrmIp, damping coefficient b_mathrmIp, and possibly anisotropic spring constants (coupling it to other nearby screened nuclear oscillators q along Cartesian directions i and j) K_mathrmIpiqj. These quantities are derived through a method briefly summarized as follows. The damping coefficients b_mathrmep and b_mathrmIp may in principle be derived ab-initio, but especially in the regime of low loss, it is sufficient for users to specify them arbitrarily. The effective nuclear masses m_mathrmIp are taken from elemental data. The remaining quantities are taken from density functional theory (DFT) calculations in the following way. The ground state electron density of the molecular body in isolation is computed using DFT, and the nuclear coordinates are relaxed to the lowest energy state; the Hessian of the ground state energy with respect to displacements in the nuclear spatial coordinates immediately yields the nuclear spring constants K_mathrmIpiqj, and the nuclear spatial coordinates vecr_p are retained as well. The ground state electron density then undergoes a Hirshfeld partitioning to give effective electron densities around each atom, accounting for local chemical effects relative to the atom in isolation, and this is then combined with accurate reference data for the static polarizability of the atom in isolation to give a static polarizability for the atom within the molecule, which will be called alpha_mathrmep0. The valence electronic oscillator has a polarizability alpha_mathrmep(omega) = fracalpha_mathrmep01 - (omegaomega_mathrmep)^2, with the frequency omega_mathrmep taken from accurate reference data in an Unsoeld approximation. This is mapped to alpha_mathrmep(omega) = fracq_mathrmep^2k_mathrmep - omega^2 m_mathrmep with the constraints q_mathrmep = N_mathrmep q_mathrme and m_mathrmep = N_mathrmep m_mathrme in terms of the known fundamental electron mass m_mathrme and charge q_mathrme to yield the total number of electrons N_mathrmep effectively constituting the valence electronic oscillator. Solving these equations yields q_mathrmep = alpha_mathrmep0 omega_mathrmep^2 m_mathrme  q_mathrme, m_mathrmep = alpha_mathrmep0 omega_mathrmep^2 m_mathrme^2  q_mathrme^2, and k_mathrmep = alpha_mathrmep0 omega_mathrmep^4 m_mathrme^2  q_mathrme^2 in terms of alpha_mathrmep0 and omega_mathrmep along with fundamental constants.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"warning: Warning\nAARMBEM.jl does not perform DFT calculations, nor does it look up reference data. All calculations required to compute alpha_mathrmep0, omega_mathrmep, and K_mathrmIpiqj must be done separately. Currently, this documentation does not provide further details in that regard.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"Once these quantities are computed, they may be arranged into matrices. The nuclear spring constants K_mathrmIpiqj can naturally be arranged into a matrix K_mathrmI due to the anisotropy and nonlocality of the couplings. The other quantities are isotropic and local (i.e. they do not involve couplings between different atoms), so quantities generally of the form a_p can be assembled as diagonal matrices A_piqj = a_p delta_pq delta_ij. These are then put together to yield the oscillator equations of motion","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"beginbmatrix\nK_mathrme - operatornameiomega B_mathrme - omega^2 M_mathrme  -K_mathrme \n-K_mathrme  K_mathrme + K_mathrmI - operatornameiomega B_mathrmI - omega^2 B_mathrmI\nendbmatrix\nbeginbmatrix\nQ_mathrme^-1 p_mathrme \nx_mathrmI\nendbmatrix\n=\nbeginbmatrix\nQ_mathrme e_mathrme \n0\nendbmatrix","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"for which the relation p_mathrme = alpha e_mathrme is then used to determine the polarizability matrix alpha entering the susceptibility mathbbV_n. Explicitly, the polarizability matrix is written as","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"alpha = Q_mathrme (K_mathrme - mathrmiomega\nB_mathrme - omega^2 M_mathrme - K_mathrme\n(K_mathrme + K_mathrmI - mathrmiomega B_mathrmI -\nomega^2 M_mathrmI)^-1 K_mathrme)^-1 Q_mathrme","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"in terms of the aforementioned matrices.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"The effective valence electronic oscillators are taken to be in their ground states, so with this in mind, the basis functions are chosen to be the oscillator ground state densities","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"vecf_pi(vecx) = left(sqrt2pi sigma_pright)^-3\nexpleft(-frac(vecx - vecr_p)^22sigma_p^2right)\nvece_i","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"in each Cartesian direction vece_i. These are defined in terms of the aforementioned nuclear coordinates vecr_p (arising from DFT) along with the Gaussian widths sigma_p, which are not arbitrary but are chosen at each frequency to depend on the polarizability matrix in the following way: the definition sigma_p(omega) = (alpha_p(omega)  3)^13  (2sqrtpi) ensures that the internal self-energy of a Gaussian-distributed polarization is equal to the energy of its electrostatic self-interaction, and the definition alpha_p (omega) = vertsum_qj alpha_pjqj (omega)vert3 takes the average over Cartesian polarization directions and transforms the nonlocal polarizability matrix into a set of effective screened atomic polarizabilities (with the absolute value ensuring real nonnegative Gaussian widths even at real omega).","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"For compact bodies (i.e. having no dimensions of infinite extent) as well as for periodic bodies (i.e. having infinite extent with discrete translational symmetry in 1 or 2 dimensions), the matrices Q_mathrme, M_mathrme, B_mathrme, K_mathrme, M_mathrmI, and B_mathrmI are all diagonal nonnegative matrices (independent of the Bloch wavevector veck in the BZ for periodic bodies). For compact bodies, K_mathrmI is a real-symmetric positive-semidefinite matrix, so K_mathrmI = K_mathrmI^top = K_mathrmI^dagger (or, more explicitly, K_mathrmIpiqj = K_mathrmIpiqj^star = K_mathrmIqjpi). This yields a reciprocal (but not Hermitian, except at imaginary frequency where it is real-symmetric positive-definite) polarizability matrix satisfying alpha = alpha^top (or, more explicitly, alpha_piqj = alpha_qjpi). For periodic bodies, evaluation of K_mathrmIveck must be done for each Bloch wavevector veck in the BZ, and K_mathrmIveck is a Hermitian positive-semidefinite matrix, so K_mathrmIveck = (K_mathrmIveck)^dagger (i.e. (K_mathrmIveck)^dagger_piqj = K^star_mathrmIveckqjpi), while reciprocity means that (K_mathrmIveck)^top = K_mathrmI(-veck) (i.e. (K_mathrmIveck)^top_piqj = K_mathrmI(-veck)qjpi). This yields the reciprocity relation for the polarizability matrix of a periodic body, namely that (alpha_veck)^top = alpha_-veck (i.e. (alpha_veck)^top_piqj = alpha_(-veck)qjpi), while specifically at imaginary frequency omega = mathrmixi, alpha_veck is a Hermitian positive-definite matrix, so alpha_veck = alpha_veck^dagger.","category":"page"},{"location":"theory/theoreticalbackground.html#Green's-functions-1","page":"Theory","title":"Green's functions","text":"","category":"section"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"Once the polarizability matrix is constructed, all that is left to represent the operators necessary for computing FED and other EM quantities is to represent the Green's functions in matrix form. In particular, the matrix elements langle vecf_pi mathbbG^mathrmmac vecf_qj rangle are required. For a general macroscopic environment, this almost always requires costly six-dimensional cubature, and that is in the easier case of semianalytical expression of mathbbG^mathrmmac. For this reason, the only macroscopic environments currently supported in AARMBEM.jl are either vacuum or a single PEC plane at z = 0, because the matrix elements langle vecf_pi mathbbG^(0) vecf_qj rangle can be expressed analytically, and image theory allows using those expressions to determine langle vecf_pi mathbbG^mathrmmac vecf_qj rangle in the presence of a PEC plane at z = 0.","category":"page"},{"location":"theory/theoreticalbackground.html#Compact-media-1","page":"Theory","title":"Compact media","text":"","category":"section"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"For compact media, the matrix elements are computed directly in real space. In particular, they are written as","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"G^(0)_piqj = langle vecf_pi mathbbG^(0) vecf_qj\nrangle = leftfracpartial^2partial r_pi partial r_pj +\n(omegac)^2 delta_ijright fracexp(-q^2 \n4)8pivertvecr_p - vecr_qvert lefte^mathrmirho\nq operatornameerfc left(-fracmathrmiq2 - rhoright) -\ne^-mathrmirho q operatornameerfc left(-fracmathrmiq2\n+ rhoright)right","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"in terms of the complementary error function operatornameerfc(u) = frac2sqrtpi int_u^infty e^-v^2mathrmdv, and in terms of the definitions of the dimensionless variables q equiv (omegac)sqrt2(sigma_p^2 + sigma_q^2) and rho equiv vertvecr_p - vecr_qvertsqrt2(sigma_p^2 + sigma_q^2). The diagonal elements G^(0)_pipj corresponding to the self-interaction of an oscillator in vacuum are taken to vanish when contribution to the T-operators for vdW interaction free energies or thermal radiation powers, but not in the contribution of the term operatornameasym(mathbbP_n mathbbG^mathrmmac) to the thermal radiation power; the diagonal elements G^mathrmsca_pjpj in the presence of a PEC plane are never taken to vanish, as the corresponding vacuum interaction is with a physically separated image dipole, not with the original dipole in itself. All of these quantities may be evaluated at real omega or at omega = mathrmixi for real nonnegative xi. At real frequency omega, the matrices G^(0) and G^mathrmmac are reciprocal, meaning G^(0) = G^(0)top and G^mathrmmac = G^mathrmmactop; at imaginary frequency omega = mathrmixi, these matrices are real-valued as well.","category":"page"},{"location":"theory/theoreticalbackground.html#Periodic-media-1","page":"Theory","title":"Periodic media","text":"","category":"section"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"For periodic media, the matrix elements G^(0)_veckpiqj = sum_vecR e^-mathrmi veck cdot vecR langle vecf_p + vecR i mathbbG^(0) vecf_qj rangle are needed in Bloch space, with Bloch wavevector veck restricted to lie in the BZ; here, vertvecf_p+vecRirangle has position space representation vecf_pi(vecx - vecR), where vecR refers to a lattice vector. In any periodic dimensionality, it is useful to write G^(0)_veckpiqj = G^(0)mathrmSR_veckpiqj + G^(0)mathrmLR_veckpiqj and make use of the Ewald summation procedure to efficiently contribute each of these two terms contributing to the sum. Further, in any periodic dimensionality, reciprocity means that (G^(0)_veck)^top = G^(0)_-veck at any frequency omega, while at imaginary frequency omega = mathrmixi, (G^(0)_veck)^dagger = G^(0)_veck; these relations also hold for G^(0)mathrmSR_veck and G^(0)mathrmLR_veck, and for G^mathrmmac_veck in the presence of a PEC plane at z = 0.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"For either 1 or 2 periodic dimensions, given lattice vectors vecR, the first contribution may be written at imaginary frequency omega = mathrmixi as","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"G^(0)mathrmSR_veckpiqj = leftfracpartial^2partial r_pi partial r_pj - (xic)^2 delta_ijright times sum_vecR frace^(sigma_p^2 + sigma_q^2)xi^2  (2c^2) - mathrmiveck cdot vecR8pivertvecr_p + vecR - vecr_qvert times \nlefte^-rhotheta leftoperatornameerfcleft(nurho - fractheta2nuright) - operatornameerfcleft(rho - fractheta2right)right + e^rhotheta leftoperatornameerfcleft(nurho + fractheta2nuright) - operatornameerfcleft(rho + fractheta2right)rightright","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"having defined the dimensionless variables rho equiv vertvecr_p + vecR - vecr_qvertsqrt2(sigma_p^2 + sigma_q^2) and theta equiv sqrt2(sigma_p^2 + sigma_q^2)xic, and where nu in 0 1 is a dimensionless parameter that is ultimately chosen by the user for convergence. The expression at real frequency omega can be obtained be consistently substituting xi = -mathrmiomega.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"For 1 periodic dimension, it shall be assumed that all lattice vectors can be written as vecR = nveca for all integers n given a primitive lattice vector veca = avece_veca (such that a = vertvecavert and vece_veca = vecaa), and the equation vecr_p - vecr_q = Delta r_parallel vece_veca + Delta vecr_perp shall define Delta r_parallel and Delta vecr_perp. Furthermore, the primitive reciprocal lattice vector is vecb = 2pivece_vecaa, reciprocal lattice vectors will satisfy vecg = nvecb for all integers n, and veck in the BZ will lie along (or opposite to) vece_veca. At imaginary frequency omega = mathrmixi, this leads to the expression","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"G^(0)mathrmLR_veckpiqj = fracvecb8pi^2 leftfracpartial^2partial r_pi partial r_pj - (xic)^2 delta_ijright times \nsum_vecg leftexp(theta^2  4 + mathrmi(veck + vecg) cdot (vecr_p - vecr_q)) sum_s = 0^infty frac(-1)^ss (nurho_perp)^2s E_s + 1 (eta^2  (4nu^2))right","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"written again in terms of theta equiv sqrt2(sigma_p^2 + sigma_q^2)xic, and where nu in 0 1 is a dimensionless parameter that is ultimately chosen by the user for convergence, and also in terms of new dimensionless quantities rho_perp = vertDeltavecr_perpvertsqrt2(sigma_p^2 + sigma_q^2) and eta^2 = theta^2 + 2(sigma_p^2 + sigma_q^2)vertveck + vecgvert^2. Also used is the definition of the exponential integral function E_s + 1(x) = s^-1 (e^-x - xE_s(x)) given E_1(x) = int_x^infty t^-1 e^-tmathrmdt. Once again, the expression at real frequency omega can be obtained be consistently substituting xi = -mathrmiomega.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"For 2 periodic dimensions, it shall be assumed that all lattice vectors can be written as vecR = n_1 veca_1 + n_2 veca_2 for all integer pairs (n_1 n_2), even if the primitive lattice vectors veca_1 and veca_2 are neither orthogonal nor unit-normalized. Furthermore, if the primitive lattice vectors are orthonormalized to yield a basis vece_1 and vece_2 defining the plane of periodicity and normal vector vece_perp, then this allows for writing reciprocal lattice vectors vecg = n_1 vecb_1 + n_2 vecb_2 for all integer pairs (n_1 n_2) in terms of the primitive reciprocal lattice vectors vecb_1 = frac2pi veca_2 times vece_perpveca_1 cdot (veca_2 times vece_perp) and vecb_2 = frac2pi vece_perp times veca_1veca_2 cdot (vece_perp times veca_1), and defining vecr_p - vecr_q = Delta r_1 vece_1 + Delta r_2 vece_2 + Delta r_perp vece_perp. At imaginary frequency omega = mathrmixi, this leads to the expression","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"G^(0)mathrmLR_veckpiqj = fracvertvecb_1 times vecb_2vert16pi^2 leftfracpartial^2partial r_pi partial r_pj - (xic)^2 delta_ijright times \nsum_vecg eta^-1 sqrt2(sigma_p^2 + sigma_q^2) exp(theta^2  4 + mathrmi(veck + vecg) cdot (vecr_p - vecr_q)) lefte^-etarho_perp operatornameerfcleft(fraceta2nu - nurho_perpright) + e^etarho_perp operatornameerfcleft(fraceta2nu + nurho_perpright)right","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"written again in terms of theta equiv sqrt2(sigma_p^2 + sigma_q^2)xic and eta^2 = theta^2 + 2(sigma_p^2 + sigma_q^2)vertveck + vecgvert^2, and where nu in 0 1 is a dimensionless parameter that is ultimately chosen by the user for convergence, and also in terms of new dimensionless quantity rho_perp = Delta r_perpsqrt2(sigma_p^2 + sigma_q^2) (which now may be negative). Once again, the expression at real frequency omega can be obtained be consistently substituting xi = -mathrmiomega.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"note: Note\nIn the above expressions, nu in 0 1 must be consistently chosen and applied to computation of both G^(0)mathrmSR and G^(0)mathrmLR. Additionally, the implementation in AARMBEM.jl asks not for nu but for a related quantity.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"warning: Warning\nConvergence is quite sensitive to the choice of nu, which will depend heavily on the geometric as well as material properties of the molecular body.","category":"page"},{"location":"theory/theoreticalbackground.html#","page":"Theory","title":"Theory","text":"[VenkataramARXIV2020]: Prashanth S. Venkataram, Jan Hermann, Alexandre Tkatchenko, and Alejandro W. Rodriguez. \"Fluctuational Electrodynamics in Atomic and Macroscopic Systems: van der Waals Interactions and Radiative Heat Transfer\". arXiv:2005.04083","category":"page"},{"location":"usage/configfiles.html#Molecular-configuration-files-1","page":"Configuration files","title":"Molecular configuration files","text":"","category":"section"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"A major ingredient of running the command-line programs in AARMBEM.jl is the molecular configuration file. The structure of such a file is described in the following sections. As discussed in the page about command-line arguments, these calculations can be done including the effects of phonons (arising from displacements of the screened nuclear oscillators), but they can also be done in the absence of phonons, effectively taking the valence electronic oscillators to be coupled to fixed, rigid nuclei.","category":"page"},{"location":"usage/configfiles.html#Configuration-file-structure-1","page":"Configuration files","title":"Configuration file structure","text":"","category":"section"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"The configuration file may have any file type, but it must be readable as plain text in a typical text editor. Given this, it is typical for the configuration file to have the .txt file type.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"For N_mathrmmol molecular bodies, the configuration file is made of N_mathrmmol blocks defining the properties of each molecular body. A block is structured as in the following example.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"MOL mol1\nQe Qefile.txt\nMe Mefile.txt\nKe Kefile.txt\nBe Befile.txt\nMI MIfile.txt\nBI BIfile.txt\nKI KIfile.txt\nxyz xyzfile.txt\nBescale 1.0\nKIconst 1.0e3\nKIconstatom1 1\nKIconstatom2 2\nENDMOL","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"In terms of formatting of this text block, leading and trailing spaces as well as blank lines are ignored. However, there are certain features that cannot be ignored or changed.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"The first line defining a block must be the word MOL (case sensitive), followed by a space, followed by a string defining the molecular label (in this example mol1); this label string can be anything, but should, for ease of use, be somehow descriptive of the molecular body. The last line, before any new block starting with MOL is defined, must be ENDMOL.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"The lines in between can be put in any order. For this molecule to be labeled n, the file used for constructing the matrices Q_mathrmen is specified as Qefile.txt, coming in the same line as Qe followed by exactly one space; no nonwhitespace characters are present after the specification of the file name. The corresponding files for M_mathrmen, K_mathrmen, B_mathrmen, M_mathrmIn, B_mathrmIn, K_mathrmIn, and the atomic coordinates come respectively as Mefile.txt, Kefile.txt, Befile.txt, MIfile.txt, BIfile.txt, KIfile.txt, and xyzfile.txt, each respectively following the keywords Me, Ke, Be, MI, BI, KI, or xyz and (in each case) following exactly one space.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"Of the above keywords, with or without phonons, the lines with Qe, Me, Ke, and xyz are required. With phonons, the keywords corresponding to the lines with MI and KI are required. With or without phonons, the keywords corresponding to the lines with Be and BI are always optional. If the line with Be is omitted, B_mathrmen is set to vanish, and likewise in the case with phonons, if the line with BI is omitted, B_mathrmIn is set to vanish; that said, if both of these vanish, thermal radiation powers will vanish, as those require nontrivial material dissipation.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"The line Bescale bescaleval allows for easily multiplying the matrix B_mathrmen by a uniform numerical factor bescaleval, which is a floating-point number that must correspond to a real nonnegative value (and may be written in scientific notation): that value bescaleval must follow the keyword Bescale and then exactly one space. In the above example, bescaleval is 1.0. This is an optional keyword, and in its absence, B_mathrmen is unchanged from what is specified through the file associated with the keyword Be.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"In the case with phonons, the line beginning with the keyword KIconst specifies an artificial spring constant to constrain one or two screened nuclear oscillators. This is useful for the following reason, as detailed later in this page. A physical spring constant matrix K_mathrmIn for a collection of N_n atoms in 3 spatial dimensions will be real-symmetric positive-semidefinite, with exactly 6 eigenvalues that are zero, with 3 modes corresponding to inertial motion of the center of mass in each of the 3 Cartesian directions, and 3 modes corresponding to rigid rotation via Euler angles about the center of mass (though for an atomically-thin linear molecular body, like a carbyne wire, one of the rotational modes disappears, so there would only be 5 eigenvalues that vanish). These zero-frequency eigenvalues lead to divergence of the polarizability matrix alpha_n as omega to 0 (along the real or imaginary axes), which could potentially lead to problems particularly for vdW interaction free energies where the integrand at omega = 0 does not vanish. A useful way of squeezing out these modes is to artificially constrain two (for compact molecular bodies, or only one for molecular bodies with commensurate discrete translational symmetry) screened nuclear oscillators with extra spring constants; for compact molecular bodies, constraining the screened nuclear oscillators that are farthest apart from each other can effectively preserve the phonon dispersion properties of most of the molecule, but for periodically extended molecular bodies, constraints are generally not recommended as their periodic repetition for all unit cells will lead to spurious modifications to the material properties.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"The artificial spring constant constraints may be specified in a few different ways; in each case, the value is given in units of newtons per meter. Also, this is an optional keyword: if that line is absent, the artificial spring constant is set by default to vanish. Following the keyword KIconst and then exactly one space, exactly 1, 3, 6, or 9 values may be specified. If the line is specified as KIconst KIconst1, where KIconst1 is a real nonnegative number specified as a floating-point value (possibly with scientific notation), then the spring constant tensor is simply KIconst1 multiplied by the 3-by-3 identity tensor, implying an isotropic coupling; in the example above, KIconst1 is 1.0e3 (i.e. 10^3mathrmNm). If that value happens to be negative, its absolute value is taken. If the line is specified as KIconst KIconst1 KIconst2 KIconst3, then the values KIconst1, KIconst2, and KIconst3 are respectively assigned as the xx-, yy-, and zz-components of a tensor that is diagonal in the basis of the Cartesian axis unit vectors; if any of these values are negative, their absolute values are used. If the line is specified as KIconst KIconst1 KIconst2 KIconst3 KIconst4 KIconst5 KIconst6, then the values KIconst1, KIconst2, KIconst3, KIconst4, KIconst5, and KIconst6 are respectively assigned as the xx-, xy-, xz-, yy-, yz-, and zz-components of a general tensor, with the yx-, zx-, and zy-components respectively assigned to be the same as the xy-, xz-, and yz-components to ensure that the tensor is real-symmetric; once this is done, the eigenvalues and eigenvectors are found, any eigenvalues that are negative are replaced by their absolute values, and these are then multiplied by the corresponding eigenvector projection operators and added again to yield a real-symmetric positive-definite tensor spring constant constraint along general orthonormal axes in 3 dimensions. If the line is specified as KIconst KIconst1 KIconst2 KIconst3 KIconst4 KIconst5 KIconst6 KIconst7 KIconst8 KIconst9, then the values KIconst1, KIconst2, KIconst3, KIconst4, KIconst5, KIconst6, KIconst7, KIconst8, and KIconst9 are respectively assigned as the xx-, xy-, xz-, yx- yy-, yz-, zx-, zy-, and zz-components of a general tensor, which is then symmetrized, following which (as in the case with 6 values specified) its eigenvectors are preserved but its eigenvalues are replaced by their absolute values (if needed) to yield a real-symmetric positive-definite tensor spring constant constraint along general orthonormal axes in 3 dimensions.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"The lines KIconstatom1 KIconstatom1val and KIconstatom2 KIconstatom2val specify which atoms are to be constrained. Both KIconstatom1val and KIconstatom2val are to be specified as integers between 1 and N_n if the molecular body labeled n has N_n atoms (in the example above, KIconstatom1val is 1 and KIconstatom2val is 2): any specification outside of this range, or any issues like KIconstatom1val being larger than or equal to KIconstatom2val, are dealt with by appropriately setting KIconstatom1val to 1 or KIconstatom2val to N_n. These are optional keywords: in their absence, the aforementioned default values of 1 and N_n are used. Furthermore, for Bloch periodic boundary conditions, only KIconstatom1val is used. Currently, AARMBEM.jl uses the same artificial spring constant constraint for both atoms in a molecular body, and does not support setting separate constraints for different screened nuclear oscillators in a given molecular body.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"The only time when a molecular body may be specified without all of this data is if it is a duplicate of another molecular body. Such a specification may be written as","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"MOL mol2\nDUPLICATE mol1\nENDMOL","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"where the keyword DUPLICATE (case sensitive) is followed by a space and then the exact string label of another molecular body, to say that these share all of their material properties and only differ in position or orientation. Any number of molecular bodies may be listed as duplicates of a given molecule body. However, the molecular label string must not itself be a duplicate (i.e. it must correspond to a molecular body whose properties are explicitly specified), and molecular bodies with explicitly specified properties must be listed before molecular bodies that are duplicates of those. For instance, the following is allowed:","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"MOL mol1\nQe Qefile1.txt\nMe Mefile1.txt\nKe Kefile1.txt\nBe Befile1.txt\nMI MIfile1.txt\nBI BIfile1.txt\nKI KIfile1.txt\nxyz xyzfile1.txt\nBescale 1.0\nKIconst 1.0e3\nKIconstatom1 1\nKIconstatom2 2\nENDMOL\n\nMOL mol2\nDUPLICATE mol1\nENDMOL\n\nMOL mol3\nDUPLICATE mol1\nENDMOL\n\nMOL mol4\nQe Qefile4.txt\nMe Mefile4.txt\nKe Kefile4.txt\nBe Befile4.txt\nMI MIfile4.txt\nBI BIfile4.txt\nKI KIfile4.txt\nxyz xyzfile4.txt\nBescale 1.0e4\nKIconst 1.0e3\nKIconstatom1 1\nKIconstatom2 2\nENDMOL\n\nMOL mol5\nDUPLICATE mol1\nENDMOL\n\nMOL mol6\nDUPLICATE mol4\nENDMOL\n\nMOL mol7\nDUPLICATE mol1\nENDMOL","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"but neither the following:","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"MOL mol1\nQe Qefile1.txt\nMe Mefile1.txt\nKe Kefile1.txt\nBe Befile1.txt\nMI MIfile1.txt\nBI BIfile1.txt\nKI KIfile1.txt\nxyz xyzfile1.txt\nBescale 1.0\nKIconst 1.0e3\nKIconstatom1 1\nKIconstatom2 2\nENDMOL\n\nMOL mol2\nDUPLICATE mol1\nENDMOL\n\nMOL mol3\nDUPLICATE mol4\nENDMOL\n\nMOL mol4\nQe Qefile4.txt\nMe Mefile4.txt\nKe Kefile4.txt\nBe Befile4.txt\nMI MIfile4.txt\nBI BIfile4.txt\nKI KIfile4.txt\nxyz xyzfile4.txt\nBescale 1.0e4\nKIconst 1.0e3\nKIconstatom1 1\nKIconstatom2 2\nENDMOL\n\nMOL mol5\nDUPLICATE mol1\nENDMOL\n\nMOL mol6\nDUPLICATE mol4\nENDMOL\n\nMOL mol7\nDUPLICATE mol1\nENDMOL","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"nor the following:","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"MOL mol1\nQe Qefile1.txt\nMe Mefile1.txt\nKe Kefile1.txt\nBe Befile1.txt\nMI MIfile1.txt\nBI BIfile1.txt\nKI KIfile1.txt\nxyz xyzfile1.txt\nBescale 1.0\nKIconst 1.0e3\nKIconstatom1 1\nKIconstatom2 2\nENDMOL\n\nMOL mol2\nDUPLICATE mol1\nENDMOL\n\nMOL mol3\nDUPLICATE mol2\nENDMOL\n\nMOL mol4\nQe Qefile4.txt\nMe Mefile4.txt\nKe Kefile4.txt\nBe Befile4.txt\nMI MIfile4.txt\nBI BIfile4.txt\nKI KIfile4.txt\nxyz xyzfile4.txt\nBescale 1.0e4\nKIconst 1.0e3\nKIconstatom1 1\nKIconstatom2 2\nENDMOL\n\nMOL mol5\nDUPLICATE mol1\nENDMOL\n\nMOL mol6\nDUPLICATE mol4\nENDMOL\n\nMOL mol7\nDUPLICATE mol1\nENDMOL","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"are allowed.","category":"page"},{"location":"usage/configfiles.html#Input-file-structure-1","page":"Configuration files","title":"Input file structure","text":"","category":"section"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"Here, the structures of the input files following the keywords Qe, Me, Ke, and so on are described.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"The files following the keywords Qe, Me, and so on can have any file type, but should be readable as plain text. In particular, the files following the keywords Qe, Me, Ke, and if present, Be, MI, and BI must a list of N_n values if molecular body n has N_n atoms, formatted as follows:","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"val1\nval2\nval3\n...\nvalNn","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"so each value should be specified as a real nonnegative floating-point quantity (possibly in scientific notation), and there should be no spaces, blank lines, or extraneous characters. The values in the files following the keywords Me and MI should be in units of kilograms, those in the files following the keywords Be and BI should be in units of kilograms per second, those in the file following the keyword Ke should be in units of newtons per meter, and those in the file following the keyword Qe should be in mathrmkg^12 cdot mathrmm^32 cdot mathrms^-1 obtained by dividing the charge in coulombs by the square root of the vacuum permittivity in SI.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"The file following the keyword xyz can have any file type, but should be readable as plain text. In particular, the file following the keyword xyz must be a list of 3 lines, each of which has N_n values separated only by commas, if molecular body n has N_n atoms, formatted as follows:","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"r_{1x},r_{2x},...,r_{Nnx}\nr_{1y},r_{2y},...,r_{Nny}\nr_{1z},r_{2z},...,r_{Nnz}","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"so each value r_pi should be specified as a real floating-point quantity (possibly in scientific notation), and there should be no spaces, blank lines, or extraneous characters. The values in the file following the keyword xyz should be in units of meters.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"The file following the keyword KI can have any file type, but should be readable as plain text. In particular, the file following the keyword xyz for a compact molecular body labeled n must be a list of 3N_n lines, each of which has 3N_n values separated only by commas, if molecular body n has N_n atoms, formatted as follows:","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"K_{I1x,1x},K_{I1x,1y},K_{I1x,1z},K_{I1x,2x},K_{I1x,2y},K_{I1x,2z},...,K_{I1x,Nnx},K_{I1x,Nny},K_{I1x,Nnz}\nK_{I1y,1x},K_{I1y,1y},K_{I1y,1z},K_{I1y,2x},K_{I1y,2y},K_{I1y,2z},...,K_{I1y,Nnx},K_{I1y,Nny},K_{I1y,Nnz}\nK_{I1z,1x},K_{I1z,1y},K_{I1z,1z},K_{I1z,2x},K_{I1z,2y},K_{I1z,2z},...,K_{I1z,Nnx},K_{I1z,Nny},K_{I1z,Nnz}\nK_{I2x,1x},K_{I2x,1y},K_{I2x,1z},K_{I2x,2x},K_{I2x,2y},K_{I2x,2z},...,K_{I2x,Nnx},K_{I2x,Nny},K_{I2x,Nnz}\nK_{I2y,1x},K_{I2y,1y},K_{I2y,1z},K_{I2y,2x},K_{I2y,2y},K_{I2y,2z},...,K_{I2y,Nnx},K_{I2y,Nny},K_{I2y,Nnz}\nK_{I2z,1x},K_{I2z,1y},K_{I2z,1z},K_{I2z,2x},K_{I2z,2y},K_{I2z,2z},...,K_{I2z,Nnx},K_{I2z,Nny},K_{I2z,Nnz}\n...,...,...,...,...,...,...,...,...,...\nK_{INnx,1x},K_{INnx,1y},K_{INnx,1z},K_{INnx,2x},K_{INnx,2y},K_{INnx,2z},...,K_{INnx,Nnx},K_{INnx,Nny},K_{INnx,Nnz}\nK_{INny,1x},K_{INny,1y},K_{INny,1z},K_{INny,2x},K_{INny,2y},K_{INny,2z},...,K_{INny,Nnx},K_{INny,Nny},K_{INny,Nnz}\nK_{INnz,1x},K_{INnz,1y},K_{INnz,1z},K_{INnz,2x},K_{INnz,2y},K_{INnz,2z},...,K_{INnz,Nnx},K_{INnz,Nny},K_{INnz,Nnz}","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"so each value K_Ipiqj should be specified as a real floating-point quantity (possibly in scientific notation), and there should be no spaces, blank lines, or extraneous characters. The values in the file following the keyword KI should be in units of newtons per meter.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"There are a few points of note for the file following the keyword KI, if present. For a compact molecular body, it must correspond to a real-symmetric positive-semidefinite matrix, with exactly 6 eigenvalues (or 5 for a purely linear 1-dimensional atomically thin wire-like molecular body) that are effectively zero (i.e. are significantly smaller in magnitude than the remaining eigenvalues, though this is left to the judgment of the user). For a molecular body obeying periodic boundary conditions, there may or may not be nonzero harmonic couplings between screened nuclear oscillators across different unit cells. If there are not, then the above format for the file following the keyword KI should be used. If there are, then a different format should be used. In particular, for 1 periodic dimension, given a unit cell (which may not be the primitive unit cell) with primitive lattice vector veca, any lattice vector may be represented as vecR = nveca for integer n (separate from the molecular labels). Likewise, for 2 periodic dimensions, given a unit cell (which may not be the primitive unit cell) with primitive lattice vectors veca_1 and veca_2 (which might not be orthogonal), any lattice vector may be represented as vecR = n_1 veca_1 + n_2 veca_2 for integers n_1 n_2. In either case, given a base unit cell labeled 0 corresponding to the lattice vector vecR = 0, the matrix block K_mathrmI(vecR 0) describes couplings from screened nuclear oscillators in unit cell 0 to those in unit cell vecR (i.e. (K_mathrmI(vecR 0))_piqj describes the coupling of the screened nuclear oscillator in atom q in unit cell 0 along Cartesian direction j to the periodic image of the screened nuclear oscillator in atom p in unit cell vecR along Cartesian direction i). Because the unit cell indexing is always of the form (vecR 0) (i.e. atom q always lies in unit cell 0), notation may be slightly abused such that in 1 periodic dimension, K_mathrmI(n) is the matrix block K_mathrmI(nveca 0), and in 2 periodic dimensions, K_mathrmI(n_1 n_2) is the matrix block K_mathrmI(n_1 veca_1 + n_2 veca_2 0). Each of the blocks K_mathrmI(n) or K_mathrmI(n_1 n_2) should be 3N_n times 3N_n (where n in the context of N_n is again the molecular label) matrices. Thus, for internuclear couplings in either 1 periodic dimension or 2 periodic dimensions where couplings are only nontrivial along veca_1, the matrix blocks should be arranged (with no blank lines in the file) as","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"beginbmatrix\nK_mathrmI(-n_1max 0) \nvdots \nK_mathrmI(-1 0) \nK_mathrmI(0 0) \nK_mathrmI(1 0) \nvdots \nK_mathrmI(n_1max 0) \nendbmatrix","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"(replacing K_mathrmI(n_1 0) in 2 periodic dimensions with K_mathrmI(n) in 1 periodic dimension) where n_1max (or n_max) is the largest unit cell index in either direction along that periodic dimension where internuclear couplings between any atom p in that unit cell and any atom q in unit cell 0 are nonzero. In 2 periodic dimensions where couplings are only nontrivial along veca_2, the matrix blocks should be arranged (through horizontal concatenation with commas as usual, with no other extraneous characters, spaces, or blank lines) as","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"beginbmatrix\nK_mathrmI(0 -n_2max)  ldots  K_mathrmI(0 -1)  K_mathrmI(0 0)  K_mathrmI(0 1)  ldots  K_mathrmI(0 n_2max) \nendbmatrix","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"where n_2max is the largest unit cell index in either direction along that periodic dimension where internuclear couplings between any atom p in that unit cell and any atom q in unit cell 0 are nonzero. In 2 periodic dimensions where couplings are nontrivial along both primitive lattice vector directions veca_1 and veca_2, the matrix blocks should be arranged (through horizontal concatenation with commas as usual and direct vertical concatenation, with no other extraneous characters, spaces, or blank lines) as","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"beginbmatrix\nK_mathrmI(-n_1max -n_2max)  ldots  K_mathrmI(-n_1max -1)  K_mathrmI(-n_1max 0)  K_mathrmI(-n_1max 1)  ldots  K_mathrmI(-n_1max n_2max) \nvdots  ddots  vdots  vdots  vdots  ddots  vdots \nK_mathrmI(-1 -n_2max)  ldots  K_mathrmI(-1 -1)  K_mathrmI(-1 0)  K_mathrmI(-1 1)  ldots  K_mathrmI(-1 n_2max) \nK_mathrmI(0 -n_2max)  ldots  K_mathrmI(0 -1)  K_mathrmI(0 0)  K_mathrmI(0 1)  ldots  K_mathrmI(0 n_2max) \nK_mathrmI(1 -n_2max)  ldots  K_mathrmI(1 -1)  K_mathrmI(1 0)  K_mathrmI(1 1)  ldots  K_mathrmI(1 n_2max) \nvdots  ddots  vdots  vdots  vdots  ddots  vdots \nK_mathrmI(n_1max -n_2max)  ldots  K_mathrmI(n_1max -1)  K_mathrmI(n_1max 0)  K_mathrmI(n_1max 1)  ldots  K_mathrmI(n_1max n_2max) \nendbmatrix","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"where n_1max and n_2max are the largest unit cell indices in either direction along that corresponding periodic dimension where internuclear couplings between any atom p in that unit cell and any atom q in unit cell 0 are nonzero.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"Whether for compact or Bloch periodic molecular bodies, the matrix K_mathrmI in real space must also satisfy two other properties. Every off-diagonal 3times 3 tensor mathbbK_mathrmIpq for atoms p neq q (and for Bloch periodic molecular bodies, this includes tensor blocks in the block matrices K_mathrmI(vecR 0) for vecR neq 0, so atom q would be in unit cell 0 while atom p may be in another unit cell vecR) must be real-symmetric negative-definite. Furthermore, the 3times 3 tensors in the diagonal blocks must satisfy K_mathrmIqiqj = -sum_p K_mathrmIpiqj, (for Cartesian tensor indices i j) where for a compact molecular body atoms p q are within the body itself while for a periodic molecular body with nontrivial couplings to other unit cells q lies within unit cell 0 while p runs over all other atoms in all unit cells (including the periodic image of q in other unit cells).","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"note: Note\nFor all of these data files, AARMBEM.jl does not check that the corresponding lists have the correct number of elements, and will simply throw an error if the formatting or list lengths are incorrect (i.e. it does not try to correct the error).","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"warning: Warning\nAs a reminder, AARMBEM.jl does not perform the DFT calculations needed to generate the relevant molecular input data files. This must be done separately.","category":"page"},{"location":"usage/configfiles.html#","page":"Configuration files","title":"Configuration files","text":"warning: Warning\nAARMBEM.jl does not check whether the matrix K_mathrmI in real space obeys the rules of positive-definiteness overall, negative-definiteness for the off-diagonal 3times 3 tensor blocks, or the summation constraint for the diagonal 3times 3 tensor blocks. These need to be verified, and enforced if need be, beforehand. Furthermore, if K_mathrmI is computed via DFT, such calculations will typically yield nontrivial couplings between all pairs of atoms at arbitrary distances (though the magnitudes will decrease significantly with increasing distance), and the results may lead to numerical error depending on the extent to which any of these conditions are violated; as a result, it may be necessary to symmetrize off-diagonal 3times 3 tensor blocks manually, set couplings beyond a certain bond distance to zero, and recompute the 3times 3 diagonal tensor blocks manually.","category":"page"},{"location":"implementation/datastructuresandtransformations.html#Data-structures-and-rigid-transformations-1","page":"Data structures and rigid transformations","title":"Data structures and rigid transformations","text":"","category":"section"},{"location":"implementation/datastructuresandtransformations.html#","page":"Data structures and rigid transformations","title":"Data structures and rigid transformations","text":"This page describes the data structures used in AARMBEM.jl, as well as conventions for rigid transformations of molecular bodies. The basic idea is that for many EM scattering calculations, including vdW interaction energies and thermal radiation powers, data is needed at each frequency (and Bloch wavevector, if appropriate) and for many different geometric configurations, in which each geometric configuration consists of a set of rigid transformations applied to molecular and macroscopic bodies; as AARMBEM.jl currently only implements vacuum or the presence of a PEC plane at z = 0 as the macroscopic body, all rigid transformations refer to those applied to molecular bodies. The data for each molecular body in isolation is independent of the rigid transformation, and therefore may be computed once per frequency (and Bloch wavevector, if appropriate); this has the additional benefit of being able to reuse data if multiple molecular bodies are used which are copies of each other in isolation. After this, data is computed for the Green's function and T-operator matrices G^mathrmmac and T for each rigid transformation (which may include translations as well as proper rotations), efficiently reusing contributions from molecular data computed in isolation when possible. Further details are given in the remainder of this page.","category":"page"},{"location":"implementation/datastructuresandtransformations.html#Molecular-data-in-isolation-1","page":"Data structures and rigid transformations","title":"Molecular data in isolation","text":"","category":"section"},{"location":"implementation/datastructuresandtransformations.html#","page":"Data structures and rigid transformations","title":"Data structures and rigid transformations","text":"In the RMB framework, every molecular body n is characterized by properties in isolation, including the number of atoms N_n, atomic coordinates vecr_p, oscillator parameters, and atomic polarizabilities. In particular, as the charges, masses, damping coefficients, and valence electronic oscillator spring constants are all isotropic, they can efficiently be stored as N_n-element vectors; only the screened nuclear oscillator spring constants must be stored as a full 3N_n times 3N_n matrix. From these quantities, the polarizability matrix alpha_n may be computed once per frequency (and Bloch wavevector, if appropriate). Furthermore, the diagonal molecular block of the vacuum Green's function matrix G^(0)_nn for each molecular body n likewise only depends on the relative positions of atoms in that body, not on absolute positions in space, and is therefore independent of rigid transformations, requiring computation only once per frequency (and Bloch wavevector, if appropriate).","category":"page"},{"location":"implementation/datastructuresandtransformations.html#","page":"Data structures and rigid transformations","title":"Data structures and rigid transformations","text":"Each molecular body can also be specified to have a certain unweighted center of mass position and a certain spatial orientation relative to the input data. Frequently, it may be desired to perform computations involving multiple molecular bodies that have entirely identical properties. It would be wasteful to duplicate molecular data in such a case, so the AARMBEM.jl code stores only data for unique molecular bodies, while separately storing only the centers of mass and orientations for each molecular body (distinguishing between otherwise identical molecular bodies). The polarizability and vacuum Green's function matrices alpha_n and G^(0)_nn for each molecular body n in isolation are reused to construct the Green's function and T-operator matrices G^mathrmmac and T, using appropriate rotation matrices to reproduce the desired orientations while translating the atomic coordinates back and forth accordingly.","category":"page"},{"location":"implementation/datastructuresandtransformations.html#Rigid-transformations-1","page":"Data structures and rigid transformations","title":"Rigid transformations","text":"","category":"section"},{"location":"implementation/datastructuresandtransformations.html#","page":"Data structures and rigid transformations","title":"Data structures and rigid transformations","text":"Each molecular body has a baseline center of mass and a baseline orientation; if none are specified, the baseline center of mass is chosen to be the origin, and the baseline orientation is chosen to be unchanged from that corresponding to the input data for the atomic coordinates for that body. Each molecular body may also undergo translations of the center of mass and rigid rotations about the center of mass; the translation vectors are relative to the baseline center of mass, and the rotations are relative to the baseline orientation.","category":"page"},{"location":"implementation/datastructuresandtransformations.html#","page":"Data structures and rigid transformations","title":"Data structures and rigid transformations","text":"Rotations are specified through Euler angles (varphi theta psi). The particular convention used by AARMBEM.jl is that an atomic coordinate vecr, represented by the column vector beginbmatrix x y z endbmatrix^top, is transformed by a rotation into R_z (-psi) R_y (-theta) R_x (-varphi) beginbmatrix x y z endbmatrix^top. The rotation matrices are defined as","category":"page"},{"location":"implementation/datastructuresandtransformations.html#","page":"Data structures and rigid transformations","title":"Data structures and rigid transformations","text":"R_x (-varphi) = beginbmatrix\n1  0  0 \n0  cos(varphi)  sin(varphi) \n0  -sin(varphi)  cos(varphi)\nendbmatrix \nR_y (-theta) = beginbmatrix\ncos(theta)  0  -sin(theta) \n0  1  0 \nsin(theta)  0  cos(theta)\nendbmatrix \nR_z (-psi) = beginbmatrix\ncos(psi)  sin(psi)  0 \n-sin(psi)  cos(psi)  0 \n0  0  1\nendbmatrix","category":"page"},{"location":"implementation/datastructuresandtransformations.html#","page":"Data structures and rigid transformations","title":"Data structures and rigid transformations","text":"in terms of these Euler angles.","category":"page"},{"location":"implementation/datastructuresandtransformations.html#","page":"Data structures and rigid transformations","title":"Data structures and rigid transformations","text":"The individual molecular matrices alpha_n and G^(0)_nn are appropriately rotated before stamping into the diagonal blocks of G^mathrmmac or T. This also accounts for the possibility that there may be molecular bodies with identical material properties but with different centers of mass or orientations (with only the latter having any effect on these matrices, with the correction being given through application of these rotation matrices as appropriate). This allows for efficient reuse of data, as computing the Green's function matrix elements is typically the computational bottleneck. Additionally, if a set of molecular bodies is not affected from one rigid transformation to the next, their diagonal and off-diagonal matrix blocks are not changed either. Rigid transformations are performed in a sorted order (regardless of the order specified), such that the displacement of the last molecular body changes first, then the displacement of the next-to-last molecular body, and so on, and then the orientation of the last molecular body, then the orientation of the next-to-last molecular body, and so on; this means that if there are many changes in position but few changes in orientation, as is often the case in many of these calculations, fewer transformations need to be applied and consequently fewer matrix blocks need to be recomputed.","category":"page"},{"location":"api/genericmatrixvectorutils.html#Generic-matrix-and-vector-utilities-1","page":"Generic matrix and vector utilities","title":"Generic matrix and vector utilities","text":"","category":"section"},{"location":"api/genericmatrixvectorutils.html#","page":"Generic matrix and vector utilities","title":"Generic matrix and vector utilities","text":"These functions can all be used independently of AARMBEM.jl.","category":"page"},{"location":"api/genericmatrixvectorutils.html#Involving-a-full-matrix-and-a-diagonal-matrix-as-a-vector-1","page":"Generic matrix and vector utilities","title":"Involving a full matrix and a diagonal matrix as a vector","text":"","category":"section"},{"location":"api/genericmatrixvectorutils.html#","page":"Generic matrix and vector utilities","title":"Generic matrix and vector utilities","text":"addtodiag!\naddtodiag\nsubtractfromdiag!\nsubtractfromdiag\nmulMatDiagleft!\nmulMatDiagleft\nmulMatDiagright!\nmulMatDiagright","category":"page"},{"location":"api/genericmatrixvectorutils.html#addtodiag!","page":"Generic matrix and vector utilities","title":"addtodiag!","text":"addtodiag!(A, v)\n\nEfficiently add the vector v in-place to the main diagonal of the matrix A (overwriting the latter). length(v) must match one of the dimensions of A, with the other dimension being at least as large, and the element types of v must be promotable to those of A. If so, yield the same result as A .= diagm(v) .+ A.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 2.0 4.0 6.0; 3.0 6.0 9.0];\n\njulia> v = [1.0; 2.0; 3.0];\n\njulia> addtodiag!(A, v)\n3×3 Array{Float64,2}:\n 2.0  2.0   3.0\n 2.0  6.0   6.0\n 3.0  6.0  12.0\n\nSee also: addtodiag, subtractfromdiag!, subtractfromdiag\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#addtodiag","page":"Generic matrix and vector utilities","title":"addtodiag","text":"addtodiag(A, v)\n\nEfficiently add the vector v not in-place to the main diagonal of the matrix A, returning the result. length(v) must match one of the dimensions of A, with the other dimension being at least as large, and the element types of v must be promotable to those of A. If so, yield the same result as diagm(v) .+ A.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 2.0 4.0 6.0; 3.0 6.0 9.0];\n\njulia> v = [1.0; 2.0; 3.0];\n\njulia> addtodiag(A, v)\n3×3 Array{Float64,2}:\n 2.0  2.0   3.0\n 2.0  6.0   6.0\n 3.0  6.0  12.0\n\nSee also: addtodiag!, subtractfromdiag!, subtractfromdiag\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#subtractfromdiag!","page":"Generic matrix and vector utilities","title":"subtractfromdiag!","text":"subtractfromdiag!(A, v)\n\nEfficiently subtract the main diagonal of the matrix A from the vector v in-place (overwriting the latter). length(v) must match one of the dimensions of A, with the other dimension being at least as large, and the element types of v must be promotable to those of A. If so, yield the same result as A .= diagm(v) .- A.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 2.0 4.0 6.0; 3.0 6.0 9.0];\n\njulia> v = [1.0; 2.0; 3.0];\n\njulia> subtractfromdiag!(A, v)\n3×3 Array{Float64,2}:\n  0.0  -2.0  -3.0\n -2.0  -2.0  -6.0\n -3.0  -6.0  -6.0\n\nSee also: addtodiag!, addtodiag, subtractfromdiag\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#subtractfromdiag","page":"Generic matrix and vector utilities","title":"subtractfromdiag","text":"subtractfromdiag(A, v)\n\nEfficiently subtract the main diagonal of the matrix A from the vector v not in-place, returning the result. length(v) must match one of the dimensions of A, with the other dimension being at least as large, and the element types of v must be promotable to those of A. If so, yield the same result as diagm(v) .- A.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 2.0 4.0 6.0; 3.0 6.0 9.0];\n\njulia> v = [1.0; 2.0; 3.0];\n\njulia> subtractfromdiag(A, v)\n3×3 Array{Float64,2}:\n 1.0  2.0  3.0\n 2.0  4.0  6.0\n 3.0  6.0  9.0\n\nSee also: addtodiag!, addtodiag, subtractfromdiag!\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#mulMatDiagleft!","page":"Generic matrix and vector utilities","title":"mulMatDiagleft!","text":"mulMatDiagleft!(A, v)\n\nEfficiently multiply each row of the matrix A by the corresponding element of the vector v in-place (overwriting the former). The element types of v must be promotable to those of A. If so, yield the same result as A .= diagm(v) * A.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 2.0 4.0 6.0; 3.0 6.0 9.0];\n\njulia> v = [1.0; 2.0; 3.0];\n\njulia> mulMatDiagleft!(A, v)\n3×3 Array{Float64,2}:\n 1.0   2.0   3.0\n 4.0   8.0  12.0\n 9.0  18.0  27.0\n\nSee also: mulMatDiagleft, mulMatDiagright!, mulMatDiagright\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#mulMatDiagleft","page":"Generic matrix and vector utilities","title":"mulMatDiagleft","text":"mulMatDiagleft(A, v)\n\nEfficiently multiply each row of the matrix A by the corresponding element of the vector v not in-place, returning the result. The element types of v must be promotable to those of A. If so, yield the same result as diagm(v) * A.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 2.0 4.0 6.0; 3.0 6.0 9.0];\n\njulia> v = [1.0; 2.0; 3.0];\n\njulia> mulMatDiagleft(A, v)\n3×3 Array{Float64,2}:\n 1.0   2.0   3.0\n 4.0   8.0  12.0\n 9.0  18.0  27.0\n\nSee also: mulMatDiagleft!, mulMatDiagright!, mulMatDiagright\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#mulMatDiagright!","page":"Generic matrix and vector utilities","title":"mulMatDiagright!","text":"mulMatDiagright!(A, v)\n\nEfficiently multiply each column of the matrix A by the corresponding element of the vector v in-place (overwriting the former). The element types of v must be promotable to those of A, and v must have the same length as the number of columns of A. If so, yield the same result as A .= A * diagm(v).\n\nExamples\n\n\njulia> A = [1.0 2.0 3.0; 2.0 4.0 6.0; 3.0 6.0 9.0];\n\njulia> v = [1.0; 2.0; 3.0];\n\njulia> mulMatDiagright!(A, v)\n3×3 Array{Float64,2}:\n 1.0   4.0   9.0\n 2.0   8.0  18.0\n 3.0  12.0  27.0\n\nSee also: mulMatDiagleft!, mulMatDiagleft, mulMatDiagright\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#mulMatDiagright","page":"Generic matrix and vector utilities","title":"mulMatDiagright","text":"mulMatDiagright(A, v)\n\nEfficiently multiply each column of the matrix A by the corresponding element of the vector v not in-place, returning the result. The element types of v must be promotable to those of A. If so, yield the same result as A * diagm(v).\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 2.0 4.0 6.0; 3.0 6.0 9.0];\n\njulia> v = [1.0; 2.0; 3.0];\n\njulia> mulMatDiagright(A, v)\n3×3 Array{Float64,2}:\n 1.0   4.0   9.0\n 2.0   8.0  18.0\n 3.0  12.0  27.0\n\nSee also: mulMatDiagleft!, mulMatDiagleft, mulMatDiagright!\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#Involving-only-a-vector-1","page":"Generic matrix and vector utilities","title":"Involving only a vector","text":"","category":"section"},{"location":"api/genericmatrixvectorutils.html#","page":"Generic matrix and vector utilities","title":"Generic matrix and vector utilities","text":"vecNto3N","category":"page"},{"location":"api/genericmatrixvectorutils.html#vecNto3N","page":"Generic matrix and vector utilities","title":"vecNto3N","text":"vecNto3N(v)\n\nReturn a vector w that is 3 times the length of v, such that each 3-element block w[3*ii-2:3*ii] has all elements identical to v[ii]. Mathematically, the vector\n\nv = beginbmatrix\nv_1 \nv_2 \nldots \nv_N\nendbmatrix^top\n\nis mapped to the vector\n\nw = beginbmatrix\nv_1 \nv_1 \nv_1 \nv_2 \nv_2 \nv_2 \nldots \nv_N \nv_N \nv_N\nendbmatrix^top\n\nExamples\n\njulia> v = [1.0; 2.0; 3.0];\n\njulia> vecNto3N(v)\n9-element Array{Float64,1}:\n 1.0\n 1.0\n 1.0\n 2.0\n 2.0\n 2.0\n 3.0\n 3.0\n 3.0\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#Involving-only-a-square-matrix-1","page":"Generic matrix and vector utilities","title":"Involving only a square matrix","text":"","category":"section"},{"location":"api/genericmatrixvectorutils.html#","page":"Generic matrix and vector utilities","title":"Generic matrix and vector utilities","text":"sympart!\nsympart\nhermpart!\nhermpart\nahermpart!\nahermpart","category":"page"},{"location":"api/genericmatrixvectorutils.html#sympart!","page":"Generic matrix and vector utilities","title":"sympart!","text":"sympart!(A)\n\nConvert a square matrix A into its symmetric part in-place (overwriting A), yielding the same result as A .= (A .+ transpose(A))./2.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0];\n\njulia> B = 1im .* A;\n\njulia> sympart!(A)\n3×3 Array{Float64,2}:\n 1.0  3.0  5.0\n 3.0  5.0  7.0\n 5.0  7.0  9.0\n\njulia> sympart!(B)\n3×3 Array{Complex{Float64},2}:\n 0.0+1.0im  0.0+3.0im  0.0+5.0im\n 0.0+3.0im  0.0+5.0im  0.0+7.0im\n 0.0+5.0im  0.0+7.0im  0.0+9.0im\n\nSee also: sympart, hermpart!, hermpart, ahermpart!, ahermpart\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#sympart","page":"Generic matrix and vector utilities","title":"sympart","text":"sympart(A)\n\nConvert a square matrix A into its symmetric part not in-place, returning the result, and yielding the same result as (A .+ transpose(A))./2.\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0];\n\njulia> B = 1im .* A;\n\njulia> sympart(A)\n3×3 Array{Float64,2}:\n 1.0  3.0  5.0\n 3.0  5.0  7.0\n 5.0  7.0  9.0\n\njulia> sympart(B)\n3×3 Array{Complex{Float64},2}:\n 0.0+1.0im  0.0+3.0im  0.0+5.0im\n 0.0+3.0im  0.0+5.0im  0.0+7.0im\n 0.0+5.0im  0.0+7.0im  0.0+9.0im\n\nSee also: sympart!, hermpart!, hermpart, ahermpart!, ahermpart\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#hermpart!","page":"Generic matrix and vector utilities","title":"hermpart!","text":"hermpart!(A)\n\nConvert a square matrix A into its Hermitian part in-place (overwriting A), yielding the same result as A .= (A .+ adjoint(A))./2. (This automatically uses sympart!() if A is real to avoid conflict with promotion to complex types.)\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0];\n\njulia> B = 1im .* A;\n\njulia> hermpart!(A)\n3×3 Array{Float64,2}:\n 1.0  3.0  5.0\n 3.0  5.0  7.0\n 5.0  7.0  9.0\n\njulia> hermpart!(B)\n3×3 Array{Complex{Float64},2}:\n 0.0+0.0im  0.0-1.0im  0.0-2.0im\n 0.0+1.0im  0.0+0.0im  0.0-1.0im\n 0.0+2.0im  0.0+1.0im  0.0+0.0im\n\nSee also: sympart!, sympart, hermpart, ahermpart!, ahermpart\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#hermpart","page":"Generic matrix and vector utilities","title":"hermpart","text":"hermpart(A)\n\nConvert a square matrix A into its Hermitian part not in-place, returning the result, and yielding the same result as (A .+ adjoint(A))./2. (Automatically use sympart() if A is real.)\n\nExamples\n\njulia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0];\n\njulia> B = 1im .* A;\n\njulia> hermpart(A)\n3×3 Array{Float64,2}:\n 1.0  3.0  5.0\n 3.0  5.0  7.0\n 5.0  7.0  9.0\n\njulia> hermpart(B)\n3×3 Array{Complex{Float64},2}:\n 0.0+0.0im  0.0-1.0im  0.0-2.0im\n 0.0+1.0im  0.0+0.0im  0.0-1.0im\n 0.0+2.0im  0.0+1.0im  0.0+0.0im\n\nSee also: sympart!, sympart, hermpart!, ahermpart!, ahermpart\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#ahermpart!","page":"Generic matrix and vector utilities","title":"ahermpart!","text":"ahermpart!(A)\n\nConvert a square matrix A into its antiHermitian part in-place (overwriting A), yielding the same result as A .= (A .- adjoint(A))./2im. (Note that the result is Hermitian.)\n\nExamples\n\njulia> B = 1im .* [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0];\n\njulia> ahermpart!(B)\n3×3 Array{Complex{Float64},2}:\n 1.0+0.0im  3.0-0.0im  5.0-0.0im\n 3.0+0.0im  5.0+0.0im  7.0-0.0im\n 5.0+0.0im  7.0+0.0im  9.0+0.0im\n\nSee also: sympart!, sympart, hermpart!, hermpart, ahermpart\n\n\n\n\n\n","category":"function"},{"location":"api/genericmatrixvectorutils.html#ahermpart","page":"Generic matrix and vector utilities","title":"ahermpart","text":"ahermpart(A)\n\nConvert a square matrix A into its antiHermitian part not in-place, returning the result, and yielding the same result as (A .- adjoint(A))./2im. (Note that the result is Hermitian.)\n\nExamples\n\njulia> B = 1im .* [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0];\n\njulia> ahermpart(B)\n3×3 Array{Complex{Float64},2}:\n 1.0+0.0im  3.0-0.0im  5.0-0.0im\n 3.0+0.0im  5.0+0.0im  7.0-0.0im\n 5.0+0.0im  7.0+0.0im  9.0+0.0im\n\nSee also: sympart!, sympart, hermpart!, hermpart, ahermpart!\n\n\n\n\n\n","category":"function"},{"location":"implementation/matrixstorage.html#Matrix-storage-conventions-1","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"","category":"section"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"This page goes over conventions for matrix storage in AARMBEM.jl. Additionally, there are subtle differences in how matrices are stored when computing vdW interaction free energy integrands versus when computing thermal radiation spectra, so these are discussed too.","category":"page"},{"location":"implementation/matrixstorage.html#Matrix-element-ordering-1","page":"Matrix storage conventions","title":"Matrix element ordering","text":"","category":"section"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"The matrices K_mathrmI and G^(0) are stored separately for each individual molecular body labeled n. Such a matrix A for an individual molecular body with N atoms, with elements A_piqj for atoms p q in 1 2 ldots N and Cartesian direction indices i j in x y z is stored in the form","category":"page"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"A = beginbmatrix\nA_1x1x  A_1x1y  A_1x1z  A_1x2x  A_1x2y  A_1x2z  ldots  A_1xNx  A_1xNy  A_1xNz \nA_1y1x  A_1y1y  A_1y1z  A_1y2x  A_1y2y  A_1y2z  ldots  A_1yNx  A_1yNy  A_1yNz \nA_1z1x  A_1z1y  A_1z1z  A_1z2x  A_1z2y  A_1z2z  ldots  A_1zNx  A_1zNy  A_1zNz \nA_2x1x  A_2x1y  A_2x1z  A_2x2x  A_2x2y  A_2x2z  ldots  A_2xNx  A_2xNy  A_2xNz \nA_2y1x  A_2y1y  A_2y1z  A_2y2x  A_2y2y  A_2y2z  ldots  A_2yNx  A_2yNy  A_2yNz \nA_2z1x  A_2z1y  A_2z1z  A_2z2x  A_2z2y  A_2z2z  ldots  A_2zNx  A_2zNy  A_2zNz \nvdots  vdots  vdots  vdots  vdots  vdots  ddots  vdots  vdots  vdots \nA_Nx1x  A_Nx1y  A_Nx1z  A_Nx2x  A_Nx2y  A_Nx2z  ldots  A_NxNx  A_NxNy  A_NxNz \nA_Ny1x  A_Ny1y  A_Ny1z  A_Ny2x  A_Ny2y  A_Ny2z  ldots  A_NyNx  A_NyNy  A_NyNz \nA_Nz1x  A_Nz1y  A_Nz1z  A_Nz2x  A_Nz2y  A_Nz2z  ldots  A_NzNx  A_NzNy  A_NzNz\nendbmatrix","category":"page"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"in AARMBEM.jl, so this is a 3N times 3N matrix.","category":"page"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"The overall T-operator and Green's function matrices T and G^mathrmmac must be stored for all molecular bodies together. Such a matrix X for the whole system has matrix blocks X_mn for molecules m n in 1 2 ldots N_mathrmmol. The actual storage in AARMBEM.jl is as a full matrix, but representing it compactly in this page is difficult. Instead, it will be represented in this page in block form as","category":"page"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"X = beginbmatrix\nX_11  X_12  ldots  X_1N_mathrmmol \nX_21  X_22  ldots  X_2N_mathrmmol \nvdots  vdots  ddots  vdots \nX_N_mathrmmol1  X_N_mathrmmol2  ldots  X_N_mathrmmolN_mathrmmol\nendbmatrix","category":"page"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"where each block is expanded as","category":"page"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"X_mn = beginbmatrix\n(X_mn)_1x1x  (X_mn)_1x1y  (X_mn)_1x1z  (X_mn)_1x2x  (X_mn)_1x2y  (X_mn)_1x2z  ldots  (X_mn)_1xN_nx  (X_mn)_1xN_ny  (X_mn)_1xN_nz \n(X_mn)_1y1x  (X_mn)_1y1y  (X_mn)_1y1z  (X_mn)_1y2x  (X_mn)_1y2y  (X_mn)_1y2z  ldots  (X_mn)_1yN_nx  (X_mn)_1yN_ny  (X_mn)_1yN_nz \n(X_mn)_1z1x  (X_mn)_1z1y  (X_mn)_1z1z  (X_mn)_1z2x  (X_mn)_1z2y  (X_mn)_1z2z  ldots  (X_mn)_1zN_nx  (X_mn)_1zN_ny  (X_mn)_1zN_nz \n(X_mn)_2x1x  (X_mn)_2x1y  (X_mn)_2x1z  (X_mn)_2x2x  (X_mn)_2x2y  (X_mn)_2x2z  ldots  (X_mn)_2xN_nx  (X_mn)_2xN_ny  (X_mn)_2xN_nz \n(X_mn)_2y1x  (X_mn)_2y1y  (X_mn)_2y1z  (X_mn)_2y2x  (X_mn)_2y2y  (X_mn)_2y2z  ldots  (X_mn)_2yN_nx  (X_mn)_2yN_ny  (X_mn)_2yN_nz \n(X_mn)_2z1x  (X_mn)_2z1y  (X_mn)_2z1z  (X_mn)_2z2x  (X_mn)_2z2y  (X_mn)_2z2z  ldots  (X_mn)_2zN_nx  (X_mn)_2zN_ny  (X_mn)_2zN_nz \nvdots  vdots  vdots  vdots  vdots  vdots  ddots  vdots  vdots  vdots \n(X_mn)_N_mx1x  (X_mn)_N_mx1y  (X_mn)_N_mx1z  (X_mn)_N_mx2x  (X_mn)_N_mx2y  (X_mn)_N_mx2z  ldots  (X_mn)_N_mxN_nx  (X_mn)_N_mxN_ny  (X_mn)_N_mxN_nz \n(X_mn)_N_my1x  (X_mn)_N_my1y  (X_mn)_N_my1z  (X_mn)_N_my2x  (X_mn)_N_my2y  (X_mn)_N_my2z  ldots  (X_mn)_N_myN_nx  (X_mn)_N_myN_ny  (X_mn)_N_myN_nz \n(X_mn)_N_mz1x  (X_mn)_N_mz1y  (X_mn)_N_mz1z  (X_mn)_N_mz2x  (X_mn)_N_mz2y  (X_mn)_N_mz2z  ldots  (X_mn)_N_mzN_nx  (X_mn)_N_mzN_ny  (X_mn)_N_mzN_nz\nendbmatrix","category":"page"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"so these blocks are each 3N_m times 3N_n matrices where molecular body m has N_m atoms and molecular body n has N_n atoms.","category":"page"},{"location":"implementation/matrixstorage.html#Matrices-in-thermal-radiation-powers-1","page":"Matrix storage conventions","title":"Matrices in thermal radiation powers","text":"","category":"section"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"For thermal radiation powers and vdW interaction free energies, the T-operator of the system is paramount. For thermal radiation in particular, the T-operator matrix is constructed by storing alpha_n^-1, G^(0)_nn, and G^mathrmmac: in particular, the total system inverse polarizability matrix is the direct sum over individual blocks alpha^-1 = bigoplus_n = 1^N_mathrmmol alpha_n^-1, and from this T = (alpha^-1 - G^mathrmmac)^-1 (where G^mathrmmac would have contributions from G^(0)_nn stamped into the diagonal blocks as appropriate). Note that alpha_n is computed for the purposes of computing atomic polarizabilities for the Gaussian basis functions, but it is more useful to store and more efficient to compute alpha_n^-1 = Q_mathrmen^-1 (K_mathrmen - mathrmiomega B_mathrmen - omega^2 M_mathrmen - K_mathrmen (K_mathrmen + K_mathrmIn - mathrmiomega B_mathrmIn - omega^2 M_mathrmIn)^-1 K_mathrmen) Q_mathrmen^-1 so alpha_n per se is not stored long-term.","category":"page"},{"location":"implementation/matrixstorage.html#Matrices-in-vdW-interaction-free-energies-1","page":"Matrix storage conventions","title":"Matrices in vdW interaction free energies","text":"","category":"section"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"There are a few differences in the matrices used for computing vdW interactions compared to those for computing thermal radiation. These changes are for the sake of greater efficiency and numerical accuracy. The expressions below are quoted for generic omega but evaluated specifically for omega = mathrmixi.","category":"page"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"The biggest change is that although the polarizability matrices alpha_n are computed for each molecular body n for computing the atomic polarizabilities for the Gaussian basis functions, neither alpha_n nor alpha_n^-1 are stored per se, and alpha_n are only computed in order to compute the atomic polarizabilities entering the Gaussian basis functions. Instead, the matrices alpha_mathrmen alpha_n^-1 = I_n - Q_mathrmen (K_mathrmen - mathrmiomega B_mathrmen - omega^2 M_mathrmen)^-1 K_mathrmen (K_mathrmen + K_mathrmIn - mathrmiomega B_mathrmIn - omega^2 M_mathrmIn)^-1 K_mathrmen Q_mathrmen^-1 (where I_n is the 3N_n times 3N_n identity matrix for molecular body n) are explicitly computed, having defined an effective electronic polarizability matrix alpha_mathrmen = Q_mathrmen (K_mathrmen - mathrmiomega B_mathrmen - omega^2 M_mathrmen)^-1 Q_mathrmen. Furthermore, instead of storing the matrices G^(0)_nn or G^mathrmmac, the matrices alpha_mathrmen G^(0)_nn and alpha_mathrme G^mathrmmac are stored, where alpha_mathrme = bigoplus_n = 1^N_mathrmmol alpha_mathrmen.","category":"page"},{"location":"implementation/matrixstorage.html#","page":"Matrix storage conventions","title":"Matrix storage conventions","text":"Effectively, the matrices alpha_mathrmen are efficient preconditioners for the matrices involved in computing the vdW interaction free energy integrand, which is evaluated as f(mathrmixi) = ln(detalpha_mathrme alpha^-1 - alpha_mathrme G^mathrmmac) - sum_n = 1^N_mathrmmol ln(detalpha_mathrmen alpha_n^-1 - alpha_mathrmen G^(0)_nn). Furthermore, the fact that all of the matrices required to compute alpha_mathrmen for each n are stored efficiently as N_n-element vectors means the same is true of alpha_mathrmen, and pre-multiplication by a diagonal matrix can be done efficiently.","category":"page"},{"location":"usage/CMDARGS.html#Command-line-arguments-1","page":"Command-line arguments","title":"Command-line arguments","text":"","category":"section"},{"location":"usage/CMDARGS.html#","page":"Command-line arguments","title":"Command-line arguments","text":"The two main programs in AARMBEM.jl are AARMBEMheat.jl, computing thermal radiation spectra, and AARMBEMvdW.jl, computing vdW interaction free energy integrands. Their command-line arguments are very similar, so this page explains how to run each.","category":"page"},{"location":"usage/CMDARGS.html#","page":"Command-line arguments","title":"Command-line arguments","text":"For each, the basic syntax of running the program is generally","category":"page"},{"location":"usage/CMDARGS.html#","page":"Command-line arguments","title":"Command-line arguments","text":"julia [-p N] PROGRAM arg1=val1 arg2=val2 [...]","category":"page"},{"location":"usage/CMDARGS.html#","page":"Command-line arguments","title":"Command-line arguments","text":"where the term [-p N] refers to the optional argument of running with a specific number of processors N, PROGRAM is either AARMBEM_heat.jl or AARMBEM_vdW.jl, and arg1, arg2, and so on are command-line argument keywords, with val1, val2, and so on being the actual corresponding argument values. The ordering of arguments does not matter, but there should be exactly one space between the end of one argument value and the beginning of the next argument keyword, and there should be no spaces between the = and the end of the argument keyword or the beginning of the argument value.","category":"page"},{"location":"usage/CMDARGS.html#Arguments-with-values-1","page":"Command-line arguments","title":"Arguments with values","text":"","category":"section"},{"location":"usage/CMDARGS.html#","page":"Command-line arguments","title":"Command-line arguments","text":"The arguments of the form arg=val are as follows.","category":"page"},{"location":"usage/CMDARGS.html#","page":"Command-line arguments","title":"Command-line arguments","text":"arg val Mandatory? Default behavior (in absence)\nmollistfilename Name of molecular configuration file Yes Error\noutfilename Name of output file for calculations Yes Error\ntranslistfilename Name of molecular transformation file No, but strongly recommended All centers of mass at origin, all orientations preserved\nperiodicfilename Name of Bloch periodicity file No, but strongly recommended for Bloch periodic systems Irrelevant for compact geometries, effective supercell for periodic geometries\nGenv PEC if above PEC plane, VAC if in vacuum No Vacuum (even if the keyword and val are present but val is anything other than exactly PEC)\nFloatType Julia floating-point data type No Float64\nfreqlistfilename Name of frequency list file One of freqlistfilename or freq is required Check for freq argument keyword\nfreq Floating-point value (in units of radians per second) for single frequency One of freqlistfilename or freq is required Error\nklistfilename Name of Bloch wavevector list file Only for Bloch periodicity, at least one of klistfilename, kx, ky, or kz is required (klistfilename supersedes others) Check for kx, ky, or kz\nkx Floating-point value (in units of radians per meter) for single k_x Only for Bloch periodicity, at least one of klistfilename, kx, ky, or kz is required (klistfilename supersedes others) Check for ky or kz\nky Floating-point value (in units of radians per meter) for single k_y Only for Bloch periodicity, at least one of klistfilename, kx, ky, or kz is required (klistfilename supersedes others) Check for kz\nkz Floating-point value (in units of radians per meter) for single k_z Only for Bloch periodicity, at least one of klistfilename, kx, ky, or kz is required (klistfilename supersedes others) Error","category":"page"},{"location":"usage/CMDARGS.html#Arguments-without-values-1","page":"Command-line arguments","title":"Arguments without values","text":"","category":"section"},{"location":"usage/CMDARGS.html#","page":"Command-line arguments","title":"Command-line arguments","text":"There are also arguments that are simply specified as arg, as follows. These arguments are all optional.","category":"page"},{"location":"usage/CMDARGS.html#","page":"Command-line arguments","title":"Command-line arguments","text":"Using the argument nophonons replaces all polarizability matrices alpha_n, and corresponding atomic polarizabilities entering the Gaussian basis functions, with purely electronic polarizabilities alpha_mathrmen = Q_mathrmen (K_mathrmen - mathrmiomega B_mathrmen - omega^2 M_mathrmen)^-1 Q_mathrmen. In its absence, the polarizability matrices alpha_n are computed as usual accounting for the effects of screened nuclear oscillators. Additionally, the value for the argument outfilename is altered: for example, the value myoutfile.out will be changed to nophonons_outfilename.out.","category":"page"},{"location":"usage/CMDARGS.html#","page":"Command-line arguments","title":"Command-line arguments","text":"Using the argument nonretarded evaluates all Green's function matrices at omega = 0, effectively reducing all long-range EM interactions to Coulomb interactions (whether in vacuum or in the presence of a PEC plane). In its absence, the Green's function matrices are evaluated at each omega (whether real or imaginary) as usual. Additionally, the value for the argument outfilename is altered: for example, the value myoutfile.out will be changed to nonretarded_outfilename.out, and if the argument nophonons is also present, the value will be changed to nonretarded_nophonons_outfilename.out.","category":"page"},{"location":"api/greensfunctions.html#Maxwell-Green's-functions-1","page":"Maxwell Green's functions","title":"Maxwell Green's functions","text":"","category":"section"},{"location":"api/greensfunctions.html#","page":"Maxwell Green's functions","title":"Maxwell Green's functions","text":"c","category":"page"},{"location":"api/greensfunctions.html#c","page":"Maxwell Green's functions","title":"c","text":"The vacuum speed of light is a global constant (299792458 meters per second).\n\n\n\n\n\n","category":"constant"},{"location":"api/greensfunctions.html#Vacuum-Green's-function-1","page":"Maxwell Green's functions","title":"Vacuum Green's function","text":"","category":"section"},{"location":"api/greensfunctions.html#","page":"Maxwell Green's functions","title":"Maxwell Green's functions","text":"This section of functions can be used outside of AARMBEM.jl.","category":"page"},{"location":"api/greensfunctions.html#","page":"Maxwell Green's functions","title":"Maxwell Green's functions","text":"GFVACGG!\nGFVACGG\nGFVACGG_sca!\nGFVACGG_sca\nGFVACGG0!\nGFVACGG0\nGFVACGG0_sca!\nGFVACGG0_sca\nGFVACGGcoincident!\nGFVACGGcoincident\nGFVACGG1Ewald!\nGFVACGG1Ewald\nGFVACGG2Ewald!\nGFVACGG2Ewald\nGFVACGGEwaldSR\nGFVACGGEwaldLR1D\nGFVACGGEwaldLR2D","category":"page"},{"location":"api/greensfunctions.html#GFVACGG!","page":"Maxwell Green's functions","title":"GFVACGG!","text":"GFVACGG!(GvacGG::AbstractArray{Complex{FT}, 2},\n         startidx1::Integer, startidx2::Integer,\n         freq::Union{FT, Complex{FT}}, blochk::Array{FT, 1},\n         posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n         latticevecs::Array{FT, 2}, reciprocalvecs::Array{FT, 2},\n         alphafield::FT, alphasource::FT,\n         numdims::Integer) where FT<:AbstractFloat\n\nFill GvacGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with the 3-by-3 Green's function interaction tensor in vacuum at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, using the appropriate function for numdims periodic dimensions (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). numdims must be 0, 1, or 2.\n\n\n\n\n\nGFVACGG!(GvacGG::AbstractArray{Complex{FT}, 2}, startidx1::Integer, startidx2::Integer,\n         freq::Union{FT, Complex{FT}},\n         posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n         alphafield::FT, alphasource::FT) where {FT<:AbstractFloat}\n\nFill GvacGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with the 3-by-3 Green's function interaction tensor in vacuum at frequency freq, corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, for nonperiodic geometries.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG","page":"Maxwell Green's functions","title":"GFVACGG","text":"GFVACGG(freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n        posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n        latticevecs::AbstractArray{FT, 2}, reciprocalvecs::AbstractArray{FT, 2},\n        alphafield::FT, alphasource::FT, numdims::Integer) where FT<:AbstractFloat\n\nReturn the 3-by-3 Green's function interaction tensor in vacuum at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, using the appropriate function for numdims periodic dimensions (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). numdims must be 0, 1, or 2.\n\n\n\n\n\nGFVACGG(freq::Union{FT, Complex{FT}},\n        posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n        alphafield::FT, alphasource::FT) where {FT<:AbstractFloat}\n\nReturn the 3-by-3 Green's function interaction tensor in vacuum at frequency freq, corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, for nonperiodic geometries.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG_sca!","page":"Maxwell Green's functions","title":"GFVACGG_sca!","text":"GFVACGG_sca!(GvacGG::AbstractArray{Complex{FT}, 2},\n             startidx1::Integer, startidx2::Integer,\n             freq::Union{FT, Complex{FT}}, blochk::Array{FT, 1},\n             posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n             latticevecs::Array{FT, 2}, reciprocalvecs::Array{FT, 2},\n             alphafield::FT, alphasource::FT,\n             numdims::Integer) where FT <: AbstractFloat\n\nFill GvacGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with a 3-by-3 block of zeros, which is the scattering Green's function in vacuum by definition, irrespective of the other function arguments. \n\n\n\n\n\nGFVACGG_sca!(GvacGG::AbstractArray{Complex{FT}, 2}, startidx1::Integer, startidx2::Integer,\n             freq::Union{FT, Complex{FT}}, posfield::AbstractArray{FT, 1},\n             possource::AbstractArray{FT, 1}, alphafield::FT,\n             alphasource::FT) where {FT<:AbstractFloat}\n\nFill GvacGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with a 3-by-3 block of zeros, which is the scattering Green's function in vacuum by definition, irrespective of the other function arguments. \n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG_sca","page":"Maxwell Green's functions","title":"GFVACGG_sca","text":"GFVACGG_sca(freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n            posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n            latticevecs::AbstractArray{FT, 2}, reciprocalvecs::AbstractArray{FT, 2},\n            alphafield::FT, alphasource::FT,\n            numdims::Integer) where {FT<:AbstractFloat}\n\nReturn a 3-by-3 block of zeros, which is the scattering Green's function in vacuum by definition, irrespective of the other function arguments. \n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG0!","page":"Maxwell Green's functions","title":"GFVACGG0!","text":"GFVACGG0!(GvacGG::AbstractArray{Complex{FT}, 2},\n          startidx1::Integer, startidx2::Integer,\n          freq::Union{FT, Complex{FT}},\n          posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n          alphafield::FT, alphasource::FT) where FT<:AbstractFloat\n\nFill GvacGG[startidx1:startidx1+2,startidx2: startidx2+2] in-place with the 3-by-3 Green's function interaction tensor in vacuum at frequency freq without spatial periodicity, corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG0","page":"Maxwell Green's functions","title":"GFVACGG0","text":"GFVACGG0(freq::Union{FT, Complex{FT}},\n         posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n         alphafield::FT, alphasource::FT) where FT<:AbstractFloat\n\nReturn the 3-by-3 Green's function interaction tensor in vacuum at frequency freq without spatial periodicity, corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG0_sca!","page":"Maxwell Green's functions","title":"GFVACGG0_sca!","text":"GFVACGG0_sca!(GvacGG::AbstractArray{Complex{FT}, 2},\n              startidx1::Integer, startidx2::Integer,\n              freq::Union{FT, Complex{FT}},\n              posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n              alphafield::FT, alphasource::FT) where FT <: AbstractFloat\n\nFill GvacGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with a 3-by-3 block of zeros, which is the scattering Green's function in vacuum by definition, irrespective of the other function arguments. \n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG0_sca","page":"Maxwell Green's functions","title":"GFVACGG0_sca","text":"GFVACGG0_sca(freq::Union{FT, Complex{FT}}, posfield::AbstractArray{FT, 1},\n             possource::AbstractArray{FT, 1}, alphafield::FT,\n             alphasource::FT) where {FT<:AbstractFloat}\n\nReturn a 3-by-3 block of zeros, which is the scattering Green's function in vacuum by definition, irrespective of the other function arguments. \n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGGcoincident!","page":"Maxwell Green's functions","title":"GFVACGGcoincident!","text":"GFVACGGcoincident!(GvacGG::AbstractArray{Complex{FT}, 2},\n                   startidx1::Integer, startidx2::Integer,\n                   freq::Union{FT, Complex{FT}}, alphafield::FT,\n                   alphasource::FT) where FT<:AbstractFloat\n\nFill GvacGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with the 3-by-3 tensor block corresponding to vacuum Green's function interaction between two Gaussian basis functions, defined by respective atomic polarizabilities alphasource and alphafield, when their centers coincide; this quantity always has a finite imaginary part, and has a finite real part when alphafield and alphasource are not both zero (meaning at least one basis function has a finite width).\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGGcoincident","page":"Maxwell Green's functions","title":"GFVACGGcoincident","text":"GFVACGGcoincident(freq::Union{FT, Complex{FT}},\n                  alphafield::FT, alphasource::FT) where FT<:AbstractFloat\n\nReturn the scalar (as the tensor is the scalar multiplied by the 3-by-3 identity) corresponding to vacuum Green's function interaction between two Gaussian basis functions, defined by respective atomic polarizabilities alphasource and alphafield, when their centers coincide; this quantity always has a finite imaginary part, and has a finite real part when alphafield and alphasource are not both zero (meaning at least one basis function has a finite width).\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG1Ewald!","page":"Maxwell Green's functions","title":"GFVACGG1Ewald!","text":"GFVACGG1Ewald!(GvacGG::AbstractArray{Complex{FT}, 2},\n               startidx1::Integer, startidx2::Integer,\n               freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n               posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n               latticevecs::AbstractArray{FT, 2},\n               reciprocalvecs::AbstractArray{FT, 2},\n               alphafield::FT, alphasource::FT) where FT<:AbstractFloat\n\nFill GvacGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with the 3-by-3 Green's function interaction tensor in vacuum at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 1 periodic dimension (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). This is done via Ewald summation over Gaussian basis functions in 1 dimension.\n\nwarning: Warning\nThe Ewald summation convergence parameters are hard-coded into this function, though they should work for most common cases.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG1Ewald","page":"Maxwell Green's functions","title":"GFVACGG1Ewald","text":"GFVACGG1Ewald(freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n              posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n              latticevecs::AbstractArray{FT, 2},\n              reciprocalvecs::AbstractArray{FT, 2},\n              alphafield::FT, alphasource::FT) where FT<:AbstractFloat\n\nReturn the 3-by-3 Green's function interaction tensor in vacuum at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 1 periodic dimension (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). This is done via Ewald summation over Gaussian basis functions in 1 dimension.\n\nwarning: Warning\nThe Ewald summation convergence parameters are hard-coded into this function, though they should work for most common cases.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG2Ewald!","page":"Maxwell Green's functions","title":"GFVACGG2Ewald!","text":"GFVACGG2Ewald!(GvacGG::AbstractArray{Complex{FT}, 2},\n               startidx1::Integer, startidx2::Integer,\n               freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n               posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n               latticevecs::AbstractArray{FT, 2},\n               reciprocalvecs::AbstractArray{FT, 2},\n               alphafield::FT, alphasource::FT) where FT<:AbstractFloat\n\nFill GvacGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with the 3-by-3 Green's function interaction tensor in vacuum at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 2 periodic dimensions (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). This is done via Ewald summation over Gaussian basis functions in 2 dimensions.\n\nwarning: Warning\nThe Ewald summation convergence parameters are hard-coded into this function, though they should work for most common cases.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGG2Ewald","page":"Maxwell Green's functions","title":"GFVACGG2Ewald","text":"GFVACGG2Ewald(freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n              posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n              latticevecs::AbstractArray{FT, 2},\n              reciprocalvecs::AbstractArray{FT, 2}, alphafield::FT,\n              alphasource::FT) where FT<:AbstractFloat\n\nReturn the 3-by-3 Green's function interaction tensor in vacuum at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 2 periodic dimensions (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). This is done via Ewald summation over Gaussian basis functions in 2 dimensions.\n\nwarning: Warning\nThe Ewald summation convergence parameters are hard-coded into this function, though they should work for most common cases.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGGEwaldSR","page":"Maxwell Green's functions","title":"GFVACGGEwaldSR","text":"GFVACGGEwaldSR(freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n               posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n               latticevecs::AbstractArray{FT, 2},\n               alphafield::FT, alphasource::FT, kappa::FT,\n               N1max::Integer, N2max::Integer=0) where FT<:AbstractFloat\n\nReturn the short-range Ewald summation contribution to the 3-by-3 Green's function interaction tensor in vacuum at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 1 or 2 periodic dimensions (with lattice parameters latticevecs for the real lattice vectors as appropriate). The sums over the real lattice run over -1*N1max:N1max and -1*N2max:N2max along each lattice vector, and kappa is the Ewald cutoff parameter.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGGEwaldLR1D","page":"Maxwell Green's functions","title":"GFVACGGEwaldLR1D","text":"GFVACGGEwaldLR1D(freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n                 posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n                 reciprocalvec::AbstractArray{FT, 1},\n                 alphafield::FT, alphasource::FT, kappa::FT,\n                 Mmax::Integer, Smax::Integer) where FT<:AbstractFloat\n\nReturn the long-range Ewald summation contribution to the 3-by-3 Green's function interaction tensor in vacuum at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 1 periodic dimension (with lattice parameters reciprocalvec for the reciprocal lattice vector as appropriate). The sum over the reciprocal lattice runs over -1*Mmax:Mmax, the sum computing the series representation of the reciprocal lattice expression runs over 0:Smax, and kappa is the Ewald cutoff parameter.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFVACGGEwaldLR2D","page":"Maxwell Green's functions","title":"GFVACGGEwaldLR2D","text":"GFVACGGEwaldLR2D(freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n                 posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n                 reciprocalvecs::AbstractArray{FT, 2},\n                 alphafield::FT, alphasource::FT, kappa::FT,\n                 M1max::Integer, M2max::Integer) where FT<:AbstractFloat\n\nReturn the long-range Ewald summation contribution to the 3-by-3 Green's function interaction tensor in vacuum at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 2 periodic dimensions (with lattice parameters reciprocalvecs for the reciprocal lattice vectors as appropriate). The sum over the reciprocal lattice runs over -1*M1max:M1max and -1*M2max:M2max along each reciprocal lattice vector, and kappa is the Ewald cutoff parameter.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#Scattering-Green's-function-above-a-PEC-plane-at-z-0-1","page":"Maxwell Green's functions","title":"Scattering Green's function above a PEC plane at z = 0","text":"","category":"section"},{"location":"api/greensfunctions.html#","page":"Maxwell Green's functions","title":"Maxwell Green's functions","text":"This section of functions can be used outside of AARMBEM.jl.","category":"page"},{"location":"api/greensfunctions.html#","page":"Maxwell Green's functions","title":"Maxwell Green's functions","text":"GFPECGG!\nGFPECGG\nGFPECGG0!\nGFPECGG0\nGFPECGG1Ewald!\nGFPECGG1Ewald\nGFPECGG2Ewald!\nGFPECGG2Ewald","category":"page"},{"location":"api/greensfunctions.html#GFPECGG!","page":"Maxwell Green's functions","title":"GFPECGG!","text":"GFPECGG!(GscaGG::AbstractArray{Complex{FT}, 2},\n         startidx1::Integer, startidx2::Integer,\n         freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n         posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n         latticevecs::AbstractArray{FT, 2}, reciprocalvecs::AbstractArray{FT, 2},\n         alphafield::FT, alphasource::FT, numdims::Integer) where FT<:AbstractFloat\n\nFill GscaGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with the 3-by-3 scattering Green's function interaction tensor above a perfect electrically conducting (PEC) plane (coplanar with the xy-plane) from the vacuum Green's function via image theory, at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, using the appropriate function for numdims periodic dimensions (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). numdims must be 0, 1, or 2.\n\n\n\n\n\nGFPECGG!(GscaGG::AbstractArray{Complex{FT}, 2},\n         startidx1::Integer, startidx2::Integer,\n         freq::Union{FT, Complex{FT}}, posfield::AbstractArray{FT, 1},\n         possource::AbstractArray{FT, 1}, alphafield::FT,\n         alphasource::FT) where {FT<:AbstractFloat}\n\nFill GscaGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with the 3-by-3 scattering Green's function interaction tensor above a perfect electrically conducting (PEC) plane (coplanar with the xy-plane) from the vacuum Green's function via image theory, at frequency freq, corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, for nonperiodic geometries.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFPECGG","page":"Maxwell Green's functions","title":"GFPECGG","text":"GFPECGG(freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n             posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n             latticevecs::AbstractArray{FT, 2}, reciprocalvecs::AbstractArray{FT, 2},\n             alphafield::FT, alphasource::FT, numdims::Integer) where FT<:AbstractFloat\n\nReturn the 3-by-3 scattering Green's function interaction tensor above a perfect electrically conducting (PEC) plane (coplanar with the xy-plane) from the vacuum Green's function via image theory, at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, using the appropriate function for numdims periodic dimensions (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). numdims must be 0, 1, or 2.\n\n\n\n\n\nGFPECGG(freq::Union{FT, Complex{FT}}, posfield::AbstractArray{FT, 1},\n        possource::AbstractArray{FT, 1}, alphafield::FT,\n        alphasource::FT) where {FT<:AbstractFloat}\n\nReturn the 3-by-3 scattering Green's function interaction tensor above a perfect electrically conducting (PEC) plane (coplanar with the xy-plane) from the vacuum Green's function via image theory, at frequency freq, corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, for nonperiodic geometries.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFPECGG0!","page":"Maxwell Green's functions","title":"GFPECGG0!","text":"GFPECGG0!(GscaGG::AbstractArray{Complex{FT}, 2},\n          startidx1::Integer, startidx2::Integer,\n          freq::Union{FT, Complex{FT}},\n          posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n          alphafield::FT, alphasource::FT) where FT<:AbstractFloat\n\nFill GscaGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with the 3-by-3 scattering Green's function interaction tensor above a perfect electrically conducting (PEC) plane (coplanar with the xy-plane) from the vacuum Green's function via image theory, at frequency freq without spatial periodicity, corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFPECGG0","page":"Maxwell Green's functions","title":"GFPECGG0","text":"GFPECGG0(freq::Union{FT, Complex{FT}}, posfield::AbstractArray{FT, 1},\n         possource::AbstractArray{FT, 1}, alphafield::FT,\n         alphasource::FT) where FT<:AbstractFloat\n\nReturn the 3-by-3 scattering Green's function interaction tensor above a perfect electrically conducting (PEC) plane (coplanar with the xy-plane) from the vacuum Green's function via image theory, at frequency freq without spatial periodicity, corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFPECGG1Ewald!","page":"Maxwell Green's functions","title":"GFPECGG1Ewald!","text":"GFPECGG1Ewald!(GscaGG::AbstractArray{Complex{FT}, 2},\n               startidx1::Integer, startidx2::Integer,\n               freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n               posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n               latticevecs::AbstractArray{FT, 2},\n               reciprocalvecs::AbstractArray{FT, 2},\n               alphafield::FT, alphasource::FT) where FT<:AbstractFloat\n\nFill GscaGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with the 3-by-3 scattering Green's function interaction tensor above a perfect electrically conducting (PEC) plane (coplanar with the xy-plane) from the vacuum Green's function via image theory, at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 1 periodic dimension (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). This is done via Ewald summation over Gaussian basis functions in 1 dimension.\n\nwarning: Warning\nThe Ewald summation convergence parameters are hard-coded into this function, though they should work for most common cases.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFPECGG1Ewald","page":"Maxwell Green's functions","title":"GFPECGG1Ewald","text":"GFPECGG1Ewald(freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n              posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n              latticevecs::AbstractArray{FT, 2},\n              reciprocalvecs::AbstractArray{FT, 2}, alphafield::FT,\n              alphasource::FT) where FT<:AbstractFloat\n\nReturn the 3-by-3 scattering Green's function interaction tensor above a perfect electrically conducting (PEC) plane (coplanar with the xy-plane) from the vacuum Green's function via image theory, at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 1 periodic dimension (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). This is done via Ewald summation over Gaussian basis functions in 1 dimension.\n\nwarning: Warning\nThe Ewald summation convergence parameters are hard-coded into this function, though they should work for most common cases.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFPECGG2Ewald!","page":"Maxwell Green's functions","title":"GFPECGG2Ewald!","text":"GFPECGG2Ewald!(GscaGG::AbstractArray{Complex{FT}, 2},\n               startidx1::Integer, startidx2::Integer,\n               freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n               posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n               latticevecs::AbstractArray{FT, 2},\n               reciprocalvecs::AbstractArray{FT, 2},\n               alphafield::FT, alphasource::FT) where FT<:AbstractFloat\n\nFill GscaGG[startidx1:startidx1+2, startidx2:startidx2+2] in-place with the 3-by-3 scattering Green's function interaction tensor above a perfect electrically conducting (PEC) plane (coplanar with the xy-plane) from the vacuum Green's function via image theory, at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 2 periodic dimensions (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). This is done via Ewald summation over Gaussian basis functions in 2 dimensions.\n\nwarning: Warning\nThe Ewald summation convergence parameters are hard-coded into this function, though they should work for most common cases.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#GFPECGG2Ewald","page":"Maxwell Green's functions","title":"GFPECGG2Ewald","text":"GFPECGG2Ewald(freq::Union{FT, Complex{FT}}, blochk::AbstractArray{FT, 1},\n              posfield::AbstractArray{FT, 1}, possource::AbstractArray{FT, 1},\n              latticevecs::AbstractArray{FT, 2},\n              reciprocalvecs::AbstractArray{FT, 2}, alphafield::FT,\n              alphasource::FT) where FT<:AbstractFloat\n\nReturn the 3-by-3 scattering Green's function interaction tensor above a perfect electrically conducting (PEC) plane (coplanar with the xy-plane) from the vacuum Green's function via image theory, at frequency freq and wavevector blochk (a 3-element vector), corresponding to source position possource and field position posfield (both 3-element vectors) described by Gaussian basis functions parameterized by real atomic polarizabilities alphasource and alphafield respectively, in 2 periodic dimensions (with lattice parameters latticevecs for the real lattice vectors and reciprocalvecs for the reciprocal lattice vectors as appropriate). This is done via Ewald summation over Gaussian basis functions in 2 dimensions.\n\nwarning: Warning\nThe Ewald summation convergence parameters are hard-coded into this function, though they should work for most common cases.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#Green's-function-matrix-assembly-routines-1","page":"Maxwell Green's functions","title":"Green's function matrix assembly routines","text":"","category":"section"},{"location":"api/greensfunctions.html#","page":"Maxwell Green's functions","title":"Maxwell Green's functions","text":"assemble1MolGvacinf!\nassemble1MolGvacinfdiag!\nsubtract1MolalphainvGvac!\nassembleGscaMolBlock!\nassembleGvacMolBlock!","category":"page"},{"location":"api/greensfunctions.html#assemble1MolGvacinf!","page":"Maxwell Green's functions","title":"assemble1MolGvacinf!","text":"assemble1MolGvacinf!(mySingleMolData::OneMol{FT}, myPeriodicData::PeriodicData{FT},\n                     freq::Union{FT, Complex{FT}},\n                     blochk::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nAssemble the Green's function interaction matrix of a single molecule in vacuum, mySingleMolData.GvacGGinf, in-place, at frequency freq and wavevector blochk using additional information from myPeriodicData to speed up the computation. In particular, if the periodic dimensionality is 0, then this matrix is symmetric (whether freq is imaginary or not). Even if the periodic dimensionality is not 0, if freq is strictly imaginary, then this matrix is Hermitian. Both of those cases allow for computing only the lower triangle of 3-by-3 blocks. Otherwise, the full matrix must be assembled.\n\nwarning: Warning\nThis function depends on mySingleMolData.alpha0 having been initialized to the desired atomic susceptibilities at the same freq and blochk, but does not check this.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#assemble1MolGvacinfdiag!","page":"Maxwell Green's functions","title":"assemble1MolGvacinfdiag!","text":"assemble1MolGvacinfdiag!(mySingleMolData::OneMol{FT},\n                         freq::Union{FT, Complex{FT}}) where FT<:AbstractFloat\n\nAssemble the scalar coincident Green's function interaction matrix elements of a single molecule in vacuum, mySingleMolData.GvacGGinfdiag, in-place, at frequency freq.\n\nwarning: Warning\nThis function depends on mySingleMolData.alpha0 having been initialized to the desired atomic susceptibilities at the same freq (and wavevector), but does not check this.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#subtract1MolalphainvGvac!","page":"Maxwell Green's functions","title":"subtract1MolalphainvGvac!","text":"subtract1MolalphainvGvac!(myMolData::OneMol{<:AbstractFloat})\n\nSubtract the Green's function interaction matrix of a single molecule in vacuum, myMolData.GvacGGinf, in-place, from its inverse susceptibility myMolData.alphainv. Separately dispatch cases with versus without phonons.\n\nwarning: Warning\nThis function depends on myMolData.alphainv having been initialized to the desired molecular susceptibility at the same freq and blochk, but does not check this.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#assembleGscaMolBlock!","page":"Maxwell Green's functions","title":"assembleGscaMolBlock!","text":"assembleGscaMolBlock!(A::SharedArray{Complex{FT}, 2},\n                      myAllMolData::MolSystem{<:OneMol{FT}},\n                      myTransData::TransData{FT}, nn1::Integer, nn2::Integer,\n                      startidx1::Integer, startidx2::Integer,\n                      myPeriodicData::PeriodicData{FT},\n                      GFSCAGG!::Function, freq::Union{FT, Complex{FT}},\n                      blochk::AbstractArray{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nAssemble the scattering Green's function interaction matrix (evaluated via the function GFSCAGG!) between molecules nn1 and nn2 (sources evaluated in the latter, fields evaluated in the former), at frequency freq and wavevector blochk, using atomic polarizability and coordinate data respectively from myAllMolData and myTransData, and add the result in-place to the matrix block A[startidx1:endidx1, startidx2:endidx2] where endidx1 - startidx1 + 1 is 3 times the number of atoms in molecule nn1, and likewise endidx2 - startidx2 + 1 is 3 times the number of atoms in molecule nn2. If nn1 and nn2 are the same, the matrix block is symmetric if the periodic dimensionality is 0, or Hermitian if the periodic dimensionality is nonzero but freq is purely imaginary, so only the lower triangle of blocks is assembled. Otherwise, the full set of matrix blocks is assembled. \n\nnote: Note\nIf GFSCAGG! is the scattering Green's function of vacuum (returning a 3-by-3 block of zeros), namely GFVACGG_sca! or GFVACGG0_sca!, this function does nothing, saving on computations.\n\nwarning: Warning\nCurrently, only GFPECGG! and GFPECGG0! are supported for GFSCAGG!, but this is not explicitly checked, and may change in future versions of this code.\n\nwarning: Warning\nThis function depends on mySingleMolData.alpha0 having been initialized to the desired atomic susceptibilities at the same freq and blochk, as well as myTransData.allAtomPos having been modified to reflect the desired transformation, but does not check these.\n\n\n\n\n\n","category":"function"},{"location":"api/greensfunctions.html#assembleGvacMolBlock!","page":"Maxwell Green's functions","title":"assembleGvacMolBlock!","text":"assembleGvacMolBlock!(A::AbstractArray{Complex{FT}, 2},\n                      myAllMolData::MolSystem{<:OneMol{FT}},\n                      myTransData::TransData{FT}, nn1::Integer, nn2::Integer,\n                      startidx1::Integer, startidx2::Integer,\n                      myPeriodicData::PeriodicData{FT},\n                      freq::Union{FT, Complex{FT}},\n                      blochk::AbstractArray{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nAssemble the vacuum Green's function interaction matrix (evaluated via the function GFVACGG!) between molecules nn1 and nn2 (sources evaluated in the latter, fields evaluated in the former), at frequency freq and wavevector blochk, using atomic polarizability and coordinate data respectively from myAllMolData and myTransData, and add the result in-place to the matrix block A[startidx1:endidx1, startidx2:endidx2] where endidx1 - startidx1 + 1 is 3 times the number of atoms in molecule nn1, and likewise endidx2 - startidx2 + 1 is 3 times the number of atoms in molecule nn2. If nn1 and nn2 are the same, the matrix block is symmetric if the periodic dimensionality is 0, or Hermitian if the periodic dimensionality is nonzero but freq is purely imaginary, so only the lower triangle of blocks is assembled. Otherwise, the full set of matrix blocks is assembled. \n\ntip: Tip\nUse assemble1MolGvacinf! when nn1 and nn2 are the same, then stamp that into A as needed. Only use this when nn1 and nn2 are different.\n\nwarning: Warning\nThis function depends on mySingleMolData.alpha0 having been initialized to the desired atomic susceptibilities at the same freq and blochk, as well as myTransData.allAtomPos having been modified to reflect the desired transformation, but does not check these.\n\n\n\n\n\n","category":"function"},{"location":"implementation/ewaldwarning.html#Ewald-summation-in-AARMBEM.jl-1","page":"Warning: Ewald summation","title":"Ewald summation in AARMBEM.jl","text":"","category":"section"},{"location":"implementation/ewaldwarning.html#","page":"Warning: Ewald summation","title":"Warning: Ewald summation","text":"warning: Warning\nThe implementation of Ewald summation for the matrix elements G^(0)_veckpiqj has several issues of which users should be aware.The code has been tested somewhat more for 2 periodic dimensions than for 1 periodic dimension, but both, particularly for 1 periodic dimension, could use more testing.\nThe sum over the order s of the exponential integral function in computing G^(0)mathrmLR_veckpiqj in 1 periodic dimension may lead to slow performance depending on the system.\nIn both 1 and 2 periodic dimensions, the sum over real lattice vectors vecR when computing G^(0)mathrmSR_veckpiqj and reciprocal lattice vectors vecg when computing G^(0)mathrmLR_veckpiqj must be truncated at some point, and the value of the parameter nu in 0 1 must be chosen appropriately. In AARMBEM.jl, these are hardcoded into the respective functions, in 1 dimension for convergence for a carbyne wire, in 2 dimensions for convergence for a graphene sheet. Consideration of other materials may likely require changing these hardcoded values.\nThe hardcoded convergence parameter choices in 2 periodic dimensions have been optimized for the RMB model of an infinite sheet of graphene. However, it is not guaranteed that other choices will actually work. For instance, the RMB model of an infinite sheet of single-layer hexagonal BN has so far failed to produce numerically well-behaved results for the G^(0)_mathrmk and G^mathrmmac_veck matrices at omega = mathrmixi.Given all of these issues, which stem from more general practical issues with Ewald summation of mathbbG^(0) even with other basis functions, users are advised, when possible, to consider avoiding treatment of infinite periodic molecular bodies and instead consider using sufficiently large supercells of finite size (which would still count as compact bodies). By image theory, all of the above issues and warnings also apply to the use of Ewald summation to compute G^mathrmmac_veckpiqj above a PEC plane at z = 0.","category":"page"},{"location":"usage/outfiles.html#Output-file-formats-1","page":"Output file structure","title":"Output file formats","text":"","category":"section"},{"location":"usage/outfiles.html#","page":"Output file structure","title":"Output file structure","text":"The code AARMBEM_vdW.jl outputs, to the chosen output file, the vdW interaction free energy integrand. Each line has the following format:","category":"page"},{"location":"usage/outfiles.html#","page":"Output file structure","title":"Output file structure","text":"translabel freq f","category":"page"},{"location":"usage/outfiles.html#","page":"Output file structure","title":"Output file structure","text":"where for compact molecular bodies, translabel is one of the transformation label strings in the molecular transformation files, freq is frequency specified as a real floating-point number (corresponding to xi) in scientific notation, and f is the dimensionless integrand f(mathrmixi) for that combination of geometrical transformation and imaginary frequency. For molecular bodies with Bloch periodicity in at least one dimension, the output format is similar, with each line having the following format:","category":"page"},{"location":"usage/outfiles.html#","page":"Output file structure","title":"Output file structure","text":"translabel freq kx ky kz f","category":"page"},{"location":"usage/outfiles.html#","page":"Output file structure","title":"Output file structure","text":"where the only differences compared to above are the presence of the real numbers kx, ky, and kz given in scientific notation corresponding to the Bloch wavevector components (k_x k_y k_z), and that f now refers to f(mathrmixi veck). The integrand value f should always be negative, and any deviations of this would be due to numerical error, hopefully restricted to places where the integrand is essentially zero anyway.","category":"page"},{"location":"usage/outfiles.html#","page":"Output file structure","title":"Output file structure","text":"The code AARMBEM_heat.jl outputs, to the chosen output file, the thermal radiation spectrum. For N compact molecular bodies, each line has the following format:","category":"page"},{"location":"usage/outfiles.html#","page":"Output file structure","title":"Output file structure","text":"translabel freq f[1, 1] f[1, 2] [...] f[1, N] f[2, 1] f[2, 2] [...] f[2, N] [...] f[N, 1] f[N, 2] [...] f[N, N]","category":"page"},{"location":"usage/outfiles.html#","page":"Output file structure","title":"Output file structure","text":"where now each entry f[m, n] is the real floating-point number equal to the dimensionless quantity frac14 Phi^(m)_n (omega) for that combination of geometrical transformation and frequency, and where Phi^(m)_n (omega) = Phi^(n)_m (omega). The entries f[n, n] should be nonpositive, while the entries f[m, n] for m != n should be nonnegative, and any deviations of this would be due to numerical error, hopefully restricted to places where the integrand is essentially zero anyway.. Similarly, for N molecular bodies with Bloch periodic boundary conditions, each line has the following format:","category":"page"},{"location":"usage/outfiles.html#","page":"Output file structure","title":"Output file structure","text":"translabel freq kx ky kz f[1, 1] f[1, 2] [...] f[1, N] f[2, 1] f[2, 2] [...] f[2, N] [...] f[N, 1] f[N, 2] [...] f[N, N]","category":"page"},{"location":"usage/outfiles.html#","page":"Output file structure","title":"Output file structure","text":"where now each entry f[m, n] is the real floating-point number equal to the dimensionless quantity frac14 Phi^(m)_n (omega veck) for that combination of geometrical transformation and frequency, and where Phi^(m)_n (omega veck) = Phi^(n)_m (omega -veck). The entries f[n, n] should be nonpositive, while the entries f[m, n] for m != n should be nonnegative, and any deviations of this would be due to numerical error, hopefully restricted to places where the integrand is essentially zero anyway..","category":"page"},{"location":"examples/guaninecytosinePEC.html#Guanine-and-cytosine-above-a-PEC-plane-1","page":"Guanine + cytosine + PEC plane","title":"Guanine and cytosine above a PEC plane","text":"","category":"section"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"This page links to examples of input files needed to compute vdW interaction free energies and thermal radiation powers in a system of compact molecular bodies. The particular system under consideration is of guanine and cytosine at the same distance z above a PEC plane (at z = 0), and where cytosine may be rotated clockwise about the z-axis through its center of mass by an angle varphi.","category":"page"},{"location":"examples/guaninecytosinePEC.html#Molecular-configuration-files-1","page":"Guanine + cytosine + PEC plane","title":"Molecular configuration files","text":"","category":"section"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"The input data files are as follows.","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"B_mathrme for cytosine: cytosineBe.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"B_mathrmI for cytosine: cytosineBI.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"K_mathrme for cytosine: cytosineKe.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"K_mathrmI for cytosine: cytosineKI_mod.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"M_mathrme for cytosine: cytosineMe.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"M_mathrmI for cytosine: cytosineMI.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"Q_mathrme for cytosine: cytosineQe.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"Atomic coordinates vecr_p for cytosine: cytosinexyz.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"B_mathrme for guanine: guanineBe.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"B_mathrmI for guanine: guanineBI.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"K_mathrme for guanine: guanineKe.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"K_mathrmI for guanine: guanineKI_mod.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"M_mathrme for guanine: guanineMe.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"M_mathrmI for guanine: guanineMI.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"Q_mathrme for guanine: guanineQe.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"Atomic coordinates vecr_p for guanine: guaninexyz.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"Overall configuration file: guaninecytosineconfig.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#Transformation-file-1","page":"Guanine + cytosine + PEC plane","title":"Transformation file","text":"","category":"section"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"Transformation file: guaninecytosinetrans.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#Frequency-file-1","page":"Guanine + cytosine + PEC plane","title":"Frequency file","text":"","category":"section"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"Frequency file: freq31.txt","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"(Many more frequencies must be used to replicate the output for vdW interaction free energies and thermal radiation powers: these can be extracted from the corresponding output files themselves. For clarity, in the example output files used, for vdW interactions, the input frequencies omega = mathrmiw used were w_n = 10^10 + (n - 1)10mathrmrads for n in 1 2 ldots 81, while for thermal radiation, the input frequencies omega = w used were w_n = n times 10^12mathrmrads for n in 1 2 ldots 500.)","category":"page"},{"location":"examples/guaninecytosinePEC.html#Output-files-1","page":"Guanine + cytosine + PEC plane","title":"Output files","text":"","category":"section"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"vdW interaction free energies: guaninecytosinePECvdW.out","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"Thermal radiation powers: guaninecytosinePECheat.out","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"note: Note\nThe ordering of output lines may vary from one run to another.","category":"page"},{"location":"examples/guaninecytosinePEC.html#Standard-commands-to-yield-these-output-files-1","page":"Guanine + cytosine + PEC plane","title":"Standard commands to yield these output files","text":"","category":"section"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"vdW interaction free energies:","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"julia -p 1 AARMBEM_vdW.jl mollistfilename=guaninecytosineconfig.txt outfilename=guaninecytosinePECvdW.out translistfilename=guaninecytosinetrans.txt freqlistfilename=freq31.txt Genv=PEC","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"Thermal radiation powers:","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"julia -p 1 AARMBEM_heat.jl mollistfilename=guaninecytosineconfig.txt outfilename=guaninecytosinePECheat.out translistfilename=guaninecytosinetrans.txt freqlistfilename=freq31.txt Genv=PEC","category":"page"},{"location":"examples/guaninecytosinePEC.html#Other-possible-examples-for-commands-(not-exhaustive)-1","page":"Guanine + cytosine + PEC plane","title":"Other possible examples for commands (not exhaustive)","text":"","category":"section"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"Thermal radiation powers in the absence of EM retardation:","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"julia -p 1 AARMBEM_heat.jl mollistfilename=guaninecytosineconfig.txt outfilename=guaninecytosinePECheat.out translistfilename=guaninecytosinetrans.txt freqlistfilename=freq31.txt Genv=PEC nonretarded","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"The output file name will actually be nonretarded_guaninecytosinePECheat.out.","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"vdW interaction free energies in the absence of phonons:","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"julia -p 1 AARMBEM_vdW.jl mollistfilename=guaninecytosineconfig.txt outfilename=guaninecytosinePECvdW.out translistfilename=guaninecytosinetrans.txt freqlistfilename=freq31.txt Genv=PEC nophonons","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"The output file name will actually be nophonons_guaninecytosinePECvdW.out.","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"vdW interaction free energies in the absence of phonons or EM retardation:","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"julia -p 1 AARMBEM_vdW.jl mollistfilename=guaninecytosineconfig.txt outfilename=guaninecytosinePECvdW.out translistfilename=guaninecytosinetrans.txt freqlistfilename=freq31.txt Genv=PEC nophonons nonretarded","category":"page"},{"location":"examples/guaninecytosinePEC.html#","page":"Guanine + cytosine + PEC plane","title":"Guanine + cytosine + PEC plane","text":"The output file name will actually be nonretarded_nophonons_guaninecytosinePECvdW.out.","category":"page"},{"location":"theory/historicalbackground.html#Historical-background-1","page":"History","title":"Historical background","text":"","category":"section"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"The RMB framework, of which AARMBEM.jl is a computational implementation, was originally developed as an extension of the many-body dispersion (MBD) framework for computing van der Waals (vdW) interaction energies. The details of this page can be found in work by Venkataram et al [VenkataramARXIV2020]; this page simply summarizes the key points.","category":"page"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"The MBD framework was developed to compute ground state vdW interaction energies in atoms and in molecular systems of many different sizes, combining ab-initio accounts of local chemical changes to electron densities in bonded atoms relative to free atoms [TkatchenkoPRL2009] with Coulomb potentials coupling each atom to account for long-range interactions [TkatchenkoPRL2012]. It has been applied to small dimers, clusters of silicon or carbon, carbon allotropes, biological molecules, organic molecular crystals, and many other systems in order to determine binding energies, structural properties, vibrational spectra, and other properties.","category":"page"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"The RMB framework initially [VenkataramPRL2017] extended this framework to account for EM retardation and the possibility that the atom-scale bodies are interacting not in vacuum but in the presence of a macroscopic body which can be modeled with a continuum susceptibility, and yielded predictions of vdW interaction energies in the presence of a gold substrate or a gold cone. Later developments in the RMB framework accounted for the contributions of phonons to EM response in atomistic structures, yielding novel predictions of thermal radiation powers [VenkataramPRL2018] and vdW interaction free energies [VenkataramSCIADV2019] of molecules and low-dimensional media in the presence of a PEC plane; however, for reasons that this and other pages make clear, this came at the cost of lesser generality in treating continuous media with respect to the practical implementation, though nothing about the theory had changed.","category":"page"},{"location":"theory/historicalbackground.html#Nomenclature-of-\"atomism\"-versus-\"continuum\"-1","page":"History","title":"Nomenclature of \"atomism\" versus \"continuum\"","text":"","category":"section"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"The notions of \"atomistic\" or \"molecular\" bodies versus \"macroscopic\" or \"continuous\" bodies are not absolute, especially given that ultimately, all bodies are made of atoms. As a rule of thumb, bodies that are smaller than about 5 nanometers in at least one dimension or feature size, or those that are less than 1 nanometer apart from each other at the smallest separation, must be treated in an ab-initio manner incorporating atom-scale effects, so we call such bodies \"atomistic\" or \"molecular\"; this includes even low-dimensional materials like carbon nanotubes, carbyne wires, or graphene sheets of infinite extent. If none of the above conditions hold, then local bulk continuum susceptibility models may suffice, and we call such bodies \"macroscopic\" or \"continuous\". We use the terms \"mesoscopic\" and \"mesoscale\" to refer to situations where there are feature sizes and separations on the order of 1-100 nanometers in which certain bodies must be treated using ab-initio atom-scale methods while others may be treated accurately using local bulk material response models.","category":"page"},{"location":"theory/historicalbackground.html#Extension-to-general-macroscopic-bodies-1","page":"History","title":"Extension to general macroscopic bodies","text":"","category":"section"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"When phonons are included, the current implementation of the RMB framework in AARMBEM.jl can only consider interactions of atom-scale systems in vacuum or in the presence of a single macroscopic body, namely a PEC plane. However, nothing about the RMB framework inherently forbids consideration of more complicated macroscopic systems, and a promising candidate for extending the AARMBEM.jl code to account for this may come through combination with the SCUFF-EM API, though there may be other candidates too with respect to computational solvers for macroscopic EM.","category":"page"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"[VenkataramARXIV2020]: Prashanth S. Venkataram, Jan Hermann, Alexandre Tkatchenko, and Alejandro W. Rodriguez. \"Fluctuational Electrodynamics in Atomic and Macroscopic Systems: van der Waals Interactions and Radiative Heat Transfer\". arXiv:2005.04083","category":"page"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"[TkatchenkoPRL2009]: Alexandre Tkatchenko and Matthias Scheffler. \"Accurate Molecular Van Der Waals Interactions from Ground-State Electron Density and Free-Atom Reference Data\". Phys. Rev. Lett. 102, 073005 (2009).","category":"page"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"[TkatchenkoPRL2012]: Alexandre Tkatchenko, Robert A. DiStasio, Jr., Roberto Car, and Matthias Scheffler. \"Accurate and Efficient Method for Many-Body van der Waals Interactions\". Phys. Rev. Lett. 108, 236402 (2012).","category":"page"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"[VenkataramPRL2017]: Prashanth S. Venkataram, Jan Hermann, Alexandre Tkatchenko, and Alejandro W. Rodriguez. \"Unifying Microscopic and Continuum Treatments of van der Waals and Casimir Interactions\". Phys. Rev. Lett. 118, 266802 (2017).","category":"page"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"[VenkataramPRL2018]: Prashanth S. Venkataram, Jan Hermann, Alexandre Tkatchenko, and Alejandro W. Rodriguez. \"Phonon-Polariton Mediated Thermal Radiation and Heat Transfer among Molecules and Macroscopic Bodies: Nonlocal Electromagnetic Response at Mesoscopic Scales\". Phys. Rev. Lett. 121, 045901 (2018).","category":"page"},{"location":"theory/historicalbackground.html#","page":"History","title":"History","text":"[VenkataramSCIADV2019]: Prashanth S. Venkataram, Jan Hermann, Teerit J. Vongkovit, Alexandre Tkatchenko, and Alejandro W. Rodriguez. \"Impact of nuclear vibrations on van der Waals and Casimir interactions at zero and finite temperature\". Sci. Adv. 5, 11, eaaw0456 (2019).","category":"page"},{"location":"theory/acronyms.html#Commonly-used-acronyms-1","page":"Common acronyms","title":"Commonly-used acronyms","text":"","category":"section"},{"location":"theory/acronyms.html#","page":"Common acronyms","title":"Common acronyms","text":"Acronym Expansion\nEM Electromagnetics\nFED Fluctuational electrodynamics\nDOF Degree of freedom\nBZ Brillouin zone\nvdW van der Waals\nRHT Radiative heat transfer\nPEC Perfect electrical conductor\nMBD Many-body dispersion\nRMB Retarded many-body\nAARMBEM Ab-initio Atomistic Retarded Many-Body Electromagnetics at the Mesoscale\nRPA Random phase approximation","category":"page"},{"location":"usage/transfiles.html#Molecular-transformation-files-1","page":"Transformation files","title":"Molecular transformation files","text":"","category":"section"},{"location":"usage/transfiles.html#","page":"Transformation files","title":"Transformation files","text":"A major ingredient of running the command-line programs in AARMBEM.jl is the molecular transformation file. For computation of vdW interaction free energies and thermal radiation powers, it is frequently useful to translate and rotate different molecular bodies in different orientations, whether in vacuum or above a PEC plane at z = 0. The following sections explain the different parts of the transformation file and their structure. The use of this file is technically optional, in that if this file is not present, then all molecular bodies are set to have their unweighted centers of mass at the origin and orientations unchanged from those respectively specified in the files associated with the keyword xyz in the molecular configuration file. However, this would lead to multiple molecular bodies overlapping with each other or with a PEC plane (if present). Therefore, this file should be used in almost all cases.","category":"page"},{"location":"usage/transfiles.html#","page":"Transformation files","title":"Transformation files","text":"The transformation file may have any file type, but it must be readable as plain text in a typical text editor. Given this, it is typical for the transformation file to have the .txt file type.","category":"page"},{"location":"usage/transfiles.html#Baseline-positions-and-orientations-1","page":"Transformation files","title":"Baseline positions and orientations","text":"","category":"section"},{"location":"usage/transfiles.html#","page":"Transformation files","title":"Transformation files","text":"The first section of the file specifies the baseline unweighted center of mass positions and orientations of all molecular bodies. As a generic example, it is structured as","category":"page"},{"location":"usage/transfiles.html#","page":"Transformation files","title":"Transformation files","text":"BASELINE\nmol1 x1 y1 z1\nmol2 x2 y2 z2 phi2 theta2 psi2\nmol4 x4 y4 z4 phi4 theta4 psi4\nmol5 x5 y5 z5\nENDBASELINE","category":"page"},{"location":"usage/transfiles.html#","page":"Transformation files","title":"Transformation files","text":"and must have the first line be BASELINE and the last line be ENDBASELINE (both case sensitive with no other spaces). In each line, the first string is the molecular label string for the corresponding molecular body (as specified in the molecular configuration file: the label string must exactly match). Following that and exactly one space can be 3 or 6 values (each separated by exactly one space, with no extraneous characters). The first, second, and third of those values respectively correspond to the x-, y-, and z- coordinates of the unweighted center of mass. The fourth, fifth, and sixth of those values respectively correspond to the Euler angles varphi, theta, and psi in degrees relative to the orientation specified in the molecular input data file for atomic coordinates. All of these are real floating point values (possibly in scientific notation). If only three values are present, then the orientation is unchanged from that specified in the molecular input data file for atomic coordinates, and the three values present correspond to the unweighted center of mass. If a molecular body is not specified in a line in this section, it is assumed to have a default unweighted center of mass at the orientation and a default orientation unchanged from that specified in the molecular input data file for atomic coordinates.","category":"page"},{"location":"usage/transfiles.html#Transformations-1","page":"Transformation files","title":"Transformations","text":"","category":"section"},{"location":"usage/transfiles.html#","page":"Transformation files","title":"Transformation files","text":"The second section of the file specifies the baseline unweighted center of mass positions and orientations of all molecular bodies relative to their baseline centers of mass and orientations. As a generic example, a transformation is structured as","category":"page"},{"location":"usage/transfiles.html#","page":"Transformation files","title":"Transformation files","text":"TRANS mytrans\nmol1 x1 y1 z1\nmol4 x4 y4 z4 phi4 theta4 psi4\nENDTRANS","category":"page"},{"location":"usage/transfiles.html#","page":"Transformation files","title":"Transformation files","text":"with the first line being the keyword TRANS (case sensitive) followed by exactly one space and then a string labeling the transformation (in this case mytrans: it should usually be descriptive or enumerated in some way for ease of extracting data later) and the last line being the keyword ENDTRANS (case sensitive). The lines in between are similar to the specification of the baseline centers of mass and orientations of each molecular body, again emphasizing the caveat that the positions and angles are actually Cartesian and angular displacements from the baseline values.","category":"page"},{"location":"implementation/outputquantities.html#Output-quantities-in-AARMBEM.jl-1","page":"Output quantities","title":"Output quantities in AARMBEM.jl","text":"","category":"section"},{"location":"implementation/outputquantities.html#","page":"Output quantities","title":"Output quantities","text":"AARMBEM.jl only outputs dimensionless integrands. It does not perform any integrations over frequency (or over Bloch wavevector, if present); this should be done by the user by appropriate sampling and interpolation over frequency (and Bloch wavevector, if appropriate).","category":"page"},{"location":"implementation/outputquantities.html#","page":"Output quantities","title":"Output quantities","text":"For compact molecular bodies, AARMBEM.jl only requires the frequency. For vdW interaction free energies, it outputs the integrand f(mathrmixi). For thermal radiation powers, it outputs one-fourth of the spectrum, namely frac14 Phi^(m)_n (omega), without any factors of the Planck function.","category":"page"},{"location":"implementation/outputquantities.html#","page":"Output quantities","title":"Output quantities","text":"For molecular bodies with commensurate discrete translational symmetries in d in 1 2 dimensions defining a unit cell of generalized volume V_mathrmuc and a BZ, AARMBEM.jl requires the frequency as well as the Bloch wavevector veck. For vdW interaction free energies, it outputs the integrand f(mathrmixi veck). For thermal radiation powers, it outputs one-fourth of the spectrum, namely frac14 Phi^(m)_n (omega veck), without any factors of the Planck function.","category":"page"},{"location":"implementation/outputquantities.html#","page":"Output quantities","title":"Output quantities","text":"AARMBEM.jl does not natively support computation of vdW forces or torques. These can be computed by appropriate setup of geometrical transformations, followed by numerical interpolation and differentiation with respect to the appropriate distance, angle, or other parameter.","category":"page"},{"location":"api/moldata.html#Molecular-data-structures-and-methods-1","page":"Molecular data structures and methods","title":"Molecular data structures and methods","text":"","category":"section"},{"location":"api/moldata.html#Data-structures-1","page":"Molecular data structures and methods","title":"Data structures","text":"","category":"section"},{"location":"api/moldata.html#","page":"Molecular data structures and methods","title":"Molecular data structures and methods","text":"OneMol\nOneMol_WithPhonons\nOneMol_NoPhonons\nMolSystem","category":"page"},{"location":"api/moldata.html#OneMol","page":"Molecular data structures and methods","title":"OneMol","text":"OneMol{FT<:AbstractFloat}\n\nRepresent properties of a single molecule, with or without phonons, as an abstract type.\n\nSee also: OneMol_WithPhonons{FT}, OneMol_NoPhonons{FT}\n\n\n\n\n\n","category":"type"},{"location":"api/moldata.html#OneMol_WithPhonons","page":"Molecular data structures and methods","title":"OneMol_WithPhonons","text":"OneMol_WithPhonons{FT} <: OneMol{FT}\n\nRepresent the properties of a single molecule of N atoms, with phonons.\n\nnumatoms is an integer equal to the number of atoms N.\n\nQe, Me, Be, Ke, MI, and BI are all numatoms-element real vectors.\n\nKI is a 3*numatoms-by-3*numatoms real matrix.\n\nmolpos0 is a 3-by-numatoms matrix where molpos0[:, p] represents the coordinates of the atom labeled p.\n\nmolCOM is a 3-element real vector containing the unweighted molecular center of mass.\n\nalphainv and GvacGGinf are 3*numatoms-by-3*numatoms complex matrices respectively representing the inverse susceptibility and Green's function interaction matrix of the molecule in isolation in vacuum (allocated but uninitialized until a frequency and wavevector are specified).\n\nalpha0 is a numatoms-element real vector of the atomic polarizabilities (allocated but uninitialized until a frequency and wavevector are specified).\n\nalphae is an numatoms-element complex vector of the purely electronic contributions to the polarizabilities, useful mainly for vdW computations (allocated but uninitialized until a frequency and wavevector are specified).\n\nnumblocks1 & numblocks2 are the integer numbers of neighboring unit cells that have nontrivial internuclear couplings to the central unit cell (each is 1 molecules that are not periodic in that direction or have no internuclear couplings/covalent bonds with neighboring unit cells in that direction).\n\nblocklist1 & blocklist2 are range vectors indexing each unit cell block (each has the single element 0 for molecules that are not periodic in that direction or have no internuclear couplings/covalent bonds with neighboring unit cells in that direction).\n\nSee also: OneMol{FT}, OneMol_NoPhonons{FT} \n\n\n\n\n\n","category":"type"},{"location":"api/moldata.html#OneMol_NoPhonons","page":"Molecular data structures and methods","title":"OneMol_NoPhonons","text":"OneMol_NoPhonons{FT} <: OneMol{FT}\n\nRepresent the properties of a single molecule of N atoms, without phonons.\n\nnumatoms is an integer equal to the number of atoms N.\n\nQe, Me, Be, and Ke are all numatoms-element real vectors.\n\nmolpos0 is a 3-by-numatoms matrix where molpos0[:, p] represents the coordinates of atom p.\n\nmolCOM is a 3-element real vector containing the unweighted molecular center of mass.\n\nalphainv is a numatoms-element complex vector representing the local inverse susceptibility of each atom (allocated but uninitialized until a frequency and wavevector are specified).\n\nGvacGGinf is a 3*numatoms-by-3*numatoms complex matrix representing the Green's function interaction matrix of the molecule in isolation in vacuum (allocated but uninitialized until a frequency and wavevector are specified).\n\nalphae is 1 ./ alphainv, useful mainly for vdW computations (allocated but uninitialized until a frequency and wavevector are specified).\n\nalpha0 is abs.(alphae), representing real atomic polarizabilities (allocated but uninitialized until a frequency and wavevector are specified).\n\nSee also: OneMol{FT}, OneMol_WithPhonons{FT} \n\n\n\n\n\n","category":"type"},{"location":"api/moldata.html#MolSystem","page":"Molecular data structures and methods","title":"MolSystem","text":"MolSystem{T<:OneMol{<:AbstractFloat}}\n\nRepresent the properties of a collection of molecules.\n\nuniqueMolDataArray contains data for each unique molecule.\n\nnummols is the total number of molecules (unique or not).\n\nnumatomslist is the list of atoms in every molecule (unique or not).\n\ncumnumatomslist is the cumulative sum of the number of atoms in every molecule, to keep track of overall indexing.\n\ndupemolinds is the list of indices tracking duplicate molecules: -1 indicates it is the first instance of that molecule, while positive index nn (in the range 1:nummols) points to nn as the molecule to be duplicated.\n\nuniquemolinds is complementary to dupemolinds, listing the index of each unique molecule in the set of unique molecules, or -1 if it is a duplicate molecule.\n\nSee also: OneMol{FT}, OneMol_WithPhonons{FT}, OneMol_NoPhonons{FT} \n\n\n\n\n\n","category":"type"},{"location":"api/moldata.html#Frequency-independent-data-structure-initialization-functions-1","page":"Molecular data structures and methods","title":"Frequency-independent data structure initialization functions","text":"","category":"section"},{"location":"api/moldata.html#","page":"Molecular data structures and methods","title":"Molecular data structures and methods","text":"read1MolDataWithPhonons\nread1MolDataNoPhonons\nreadMolSystem","category":"page"},{"location":"api/moldata.html#read1MolDataWithPhonons","page":"Molecular data structures and methods","title":"read1MolDataWithPhonons","text":"read1MolDataWithPhonons(molstrarray::Array{<:AbstractString, 1},\n                        mollistfilename::AbstractString, T::DataType=Float64)\n\nRead a section of a configuration file molstrarray (an array of strings) corresponding to molecular data and return the data corresponding to that molecule, with phonons, of type OneMol_WithPhonons{T}. Create data types to use T (satisfying T<:AbstractFloat) for storing floating-point numbers, and output any errors with reference to the configuration file mollistfilename (a string).\n\nSee also: OneMol{FT}, OneMol_WithPhonons{FT} \n\n\n\n\n\n","category":"function"},{"location":"api/moldata.html#read1MolDataNoPhonons","page":"Molecular data structures and methods","title":"read1MolDataNoPhonons","text":"read1MolDataNoPhonons(molstrarray::Array{<:AbstractString, 1},\n                      mollistfilename::AbstractString, T::DataType=Float64)\n\nRead a section of a configuration file molstrarray (an array of strings) corresponding to molecular data and return the data corresponding to that molecule, without phonons, of type OneMol_NoPhonons{T}. Create data types to use T (satisfying T<:AbstractFloat) for storing floating-point numbers, and output any errors with reference to the configuration file mollistfilename (a string).\n\nSee also: OneMol{FT}, OneMol_NoPhonons{FT} \n\n\n\n\n\n","category":"function"},{"location":"api/moldata.html#readMolSystem","page":"Molecular data structures and methods","title":"readMolSystem","text":"readMolSystem(mollistfilename::AbstractString,\n              nophonons:Bool, T::DataType=Float64)\n\nRead a configuration file mollistfilename (a string) to extract molecular data of type either OneMol_NoPhonons{T}, if nophonons is true, or OneMol_WithPhonons{T} otherwise, returning information about the composite system of type MolSystem{molType{T}}. Ensure data types use T (satisfying T<:AbstractFloat) for storing floating-point numbers.\n\nSee also: OneMol{T}, OneMol_WithPhonons{T}, OneMol_NoPhonons{T}, MolSystem{molType{T}}\n\n\n\n\n\n","category":"function"},{"location":"api/moldata.html#Frequency-dependent-polarizability-calculation-functions-1","page":"Molecular data structures and methods","title":"Frequency-dependent polarizability calculation functions","text":"","category":"section"},{"location":"api/moldata.html#","page":"Molecular data structures and methods","title":"Molecular data structures and methods","text":"constructMolAlpha!(myMolData::OneMol_WithPhonons{FT}, myPeriodicData::PeriodicData{FT}, freq::Union{FT, Complex{FT}}, k::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\nconstructMolAlpha!(myMolData::OneMol_NoPhonons{FT}, myPeriodicData::PeriodicData{FT}, freq::Union{FT, Complex{FT}}, k::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\nKIk","category":"page"},{"location":"api/moldata.html#constructMolAlpha!-Union{Tuple{FT}, Tuple{OneMol_WithPhonons{FT},PeriodicData{FT},Union{Complex{FT}, FT}}, Tuple{OneMol_WithPhonons{FT},PeriodicData{FT},Union{Complex{FT}, FT},Array{FT,1}}} where FT<:AbstractFloat","page":"Molecular data structures and methods","title":"constructMolAlpha!","text":"constructMolAlpha!(myMolData::OneMol_WithPhonons{FT},\n                   myPeriodicData::PeriodicData{FT},\n                   freq::Union{FT, Complex{FT}},\n                   k::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nConstruct the inverse molecular susceptibility myMolData.alphainv in-place at frequency freq and wavevector k, the latter of which must be a 3-element real vector. With phonons, myMolData.alphainv will be a matrix, the vector of atomic polarizabilities myMolData.alpha0 will depend on the elements of myMolData.alphainv, and myMolData.alphae will be independent of these two. Without phonons, all three will be simply related to each other.\n\n\n\n\n\n","category":"method"},{"location":"api/moldata.html#constructMolAlpha!-Union{Tuple{FT}, Tuple{OneMol_NoPhonons{FT},PeriodicData{FT},Union{Complex{FT}, FT}}, Tuple{OneMol_NoPhonons{FT},PeriodicData{FT},Union{Complex{FT}, FT},Array{FT,1}}} where FT<:AbstractFloat","page":"Molecular data structures and methods","title":"constructMolAlpha!","text":"constructMolAlpha!(myMolData::OneMol_NoPhonons{FT},\n                   myPeriodicData::PeriodicData{FT},\n                   freq::Union{FT, Complex{FT}},\n                   k::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nConstruct the inverse molecular susceptibility myMolData.alphainv in-place at frequency freq and wavevector k, the latter of which must be a 3-element real vector. Without phonons, myMolData.alphainv will be a vector, and the vectors myMolData.alpha0 and myMolData.alphae will be simply related to myMolData.alphainv.\n\n\n\n\n\n","category":"method"},{"location":"api/moldata.html#KIk","page":"Molecular data structures and methods","title":"KIk","text":"KIk(myMolData::OneMol_WithPhonons{FT}, myPeriodicData::PeriodicData{FT},\n    k::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat\n\nConstruct the k-dependence of the internuclear spring constant matrix (only if phonons are present), and return the result. Return myMolData.KI if the geometry has no periodic dimensions.\n\nSee also: constructMolAlpha!(myMolData::OneMol_WithPhonons{FT},                        myPeriodicData::PeriodicData{FT},                        freq::Union{FT, Complex{FT}},                        k::Array{FT, 1}=zeros(FT, 3)) where FT<:AbstractFloat.\n\n\n\n\n\n","category":"function"},{"location":"usage/periodicfiles.html#Molecular-Bloch-periodicity-files-1","page":"Bloch periodicity files","title":"Molecular Bloch periodicity files","text":"","category":"section"},{"location":"usage/periodicfiles.html#","page":"Bloch periodicity files","title":"Bloch periodicity files","text":"An ingredient of running the command-line programs in AARMBEM.jl is the file specifying Bloch periodicity. This is optional, and should only be used if Bloch periodicity is present. If this file is not supplied, the default behavior is to assume no Bloch periodicity (i.e. compact molecular bodies).","category":"page"},{"location":"usage/periodicfiles.html#","page":"Bloch periodicity files","title":"Bloch periodicity files","text":"The Bloch periodicity file may have any file type, but it must be readable as plain text in a typical text editor. Given this, it is typical for the Bloch periodicity file to have the .txt file type.","category":"page"},{"location":"usage/periodicfiles.html#","page":"Bloch periodicity files","title":"Bloch periodicity files","text":"If there is discrete translational symmetry in only 1 dimension, the file should simply have 3 values","category":"page"},{"location":"usage/periodicfiles.html#","page":"Bloch periodicity files","title":"Bloch periodicity files","text":"ax\nay\naz","category":"page"},{"location":"usage/periodicfiles.html#","page":"Bloch periodicity files","title":"Bloch periodicity files","text":"where the values ax, ay, and az are replaced by real floating-point numbers (possibly in scientific notation) representing the Cartesian components of the lattice vector veca.","category":"page"},{"location":"usage/periodicfiles.html#","page":"Bloch periodicity files","title":"Bloch periodicity files","text":"If there is discrete translational symmetry in 1 dimensions, the file should have 6 values","category":"page"},{"location":"usage/periodicfiles.html#","page":"Bloch periodicity files","title":"Bloch periodicity files","text":"a1x\na1y\na1z\na2x\na2y\na2z","category":"page"},{"location":"usage/periodicfiles.html#","page":"Bloch periodicity files","title":"Bloch periodicity files","text":"where the values a1x, a1y, a1z, a2x, a2y, and a2z are replaced by real floating-point numbers (possibly in scientific notation) representing the Cartesian components of the respective lattice vector veca_1 and veca_2.","category":"page"},{"location":"usage/periodicfiles.html#","page":"Bloch periodicity files","title":"Bloch periodicity files","text":"In both cases, there should be no extraneous characters, spaces, or blank lines.","category":"page"},{"location":"api/expintegral.html#Exponential-integral-function-1","page":"Exponential integral function","title":"Exponential integral function","text":"","category":"section"},{"location":"api/expintegral.html#","page":"Exponential integral function","title":"Exponential integral function","text":"These functions can all be used independently of AARMBEM.jl","category":"page"},{"location":"api/expintegral.html#","page":"Exponential integral function","title":"Exponential integral function","text":"E1func\nE1taylor\nE1cf","category":"page"},{"location":"api/expintegral.html#E1func","page":"Exponential integral function","title":"E1func","text":"E1func(x)\n\nCompute the exponential integral function E_1(x) for a real number x. This function returns zero if x is larger than 700, or Inf + pi*1im if x is smaller than -700. (This definition also defines the branch taken in the complex plane for x  0.) Note that even though E_1(x) is real for x  0, the result of E1func(x) is cast as a complex type, based on the type of x, for consistency.\n\nThis is a reimplementation of code at https://github.com/mitmath/18S096/blob/iap2017/pset3/pset3-solutions.ipynb by Steven G. Johnson, based on a combination of Taylor series and continued fraction expansions.\n\nSee also: E1taylor, E1cf\n\n\n\n\n\n","category":"function"},{"location":"api/expintegral.html#E1taylor","page":"Exponential integral function","title":"E1taylor","text":"E1taylor(x, maxorder)\n\nCompute the exponential integral function E_1(x) for a real number x, using the Taylor series expansion up to a maximum order maxorder. This function works best for -30 leq x leq 3.\n\nThis is a reimplementation of code at https://github.com/mitmath/18S096/blob/iap2017/pset3/pset3-solutions.ipynb by Steven G. Johnson.\n\nSee also: E1func, E1cf\n\n\n\n\n\n","category":"function"},{"location":"api/expintegral.html#E1cf","page":"Exponential integral function","title":"E1cf","text":"E1cf(x, maxorder)\n\nCompute the exponential integral function E_1(x) for a real number x, using the continued fraction expansion up to a maximum order maxorder. This function works best for x  -30 or x  3.\n\nThis is a reimplementation of code at https://github.com/mitmath/18S096/blob/iap2017/pset3/pset3-solutions.ipynb by Steven G. Johnson.\n\nSee also: E1func, E1taylor\n\n\n\n\n\n","category":"function"},{"location":"implementation/units.html#Units-in-AARMBEM.jl-1","page":"Units","title":"Units in AARMBEM.jl","text":"","category":"section"},{"location":"implementation/units.html#","page":"Units","title":"Units","text":"AARMBEM.jl uses a \"Lorentz-Heaviside SI\" unit system. This means that the mass, length, and time units are the standard SI units of kilograms, meters, and seconds. However, EM units are defined by the Lorentz-Heaviside convention for Maxwell's equations, namely","category":"page"},{"location":"implementation/units.html#","page":"Units","title":"Units","text":"nabla cdot vecE = rho \nnabla cdot vecB = 0 \nnabla times vecE = -frac1c fracpartial vecBpartial t \nnabla times vecB = frac1c left(vecJ + fracpartial vecEpartial tright)","category":"page"},{"location":"implementation/units.html#","page":"Units","title":"Units","text":"such that vecE and vecB have the same units as each other. In material media, they also have the same units as vecD and vecH. This is trivially true for the magnetic field, with vecB = vecH, as AARMBEM.jl currently does not support consideration of nontrivial magnetic susceptibilities. For the electric field, this means vecD = vecE + vecP, where in the frequency domain P_i (vecx) = sum_j int V_ij (vecx vecx) E_j (vecx)mathrmd^3 x, so the frequency domain kernel V_ij (vecx vecx) has units of inverse spatial volume. For a local homogeneous isotropic medium with V_ij (vecx vecx) = chi Theta(vecx in V) delta_ij delta^3 (vecx - vecx), the susceptibility chi is dimensionless and is related to the permittivity epsilon = 1 + chi: this aligns with the SI convention (without the factor of epsilon_0), not the Gaussian CGS convention. Additionally, in the frequency domain, the vacuum Maxwell Green's function is defined to satisfy","category":"page"},{"location":"implementation/units.html#","page":"Units","title":"Units","text":"sum_k (partial_i partial_k G^(0)_kj (vecx vecx) -\npartial_k partial_k G^(0)_ij (vecx vecx)) -\n(omegac)^2 G^(0)_ij (vecx vecx) = (omegac)^2\ndelta_ij delta^3 (vecx - vecx)","category":"page"},{"location":"implementation/units.html#","page":"Units","title":"Units","text":"with the explicit outgoing solution G^(0)_ij (vecx vecx) = partial_i partial_j + (omegac)^2 delta_ij(e^mathrmiomegavertvecx - vecxvertc(4pivertvecx - vecxvert)), where partial_i = fracpartialpartial x_i; this means G^(0)_ij (vecx vecx), along with G^mathrmmac_ij(vecx vecx) for any macroscopic body, have units in position space of inverse spatial volume.","category":"page"},{"location":"implementation/units.html#Units-of-input-parameters-1","page":"Units","title":"Units of input parameters","text":"","category":"section"},{"location":"implementation/units.html#","page":"Units","title":"Units","text":"Various functions require evaluation at frequency omega (whether real or imaginary), positions vecr_p and vecr_q, and optionally the Bloch wavevector veck. The frequencies omega are consistently taken to be angular frequencies in units of radians per second: the Fourier expansion in time in terms of frequency is defined to be g(t) = int_-infty^infty e^-mathrmiomega t tildeg(omega)fracmathrmdomega2pi, and the Fourier transform from time to frequency is tildeg(omega) = int_-infty^infty e^mathrmiomega t g(t)mathrmdt. The components of wavevectors veck are consistently taken to be angular wavevectors in units of radians per meter: the Fourier expansion in position in terms of wavevector is defined to be f(vecx) = int e^mathrmiveck cdot vecx tildef(veck)fracmathrmd^d k(2pi)^d, and the Fourier transform from position to wavevector is tildef(veck) = int e^-mathrmiveck cdot vecx f(vecx)mathrmd^d x. The positions simply use the standard SI unit of meters for all vector components.","category":"page"},{"location":"implementation/units.html#","page":"Units","title":"Units","text":"Beyond these, there are several key inputs required by AARMBEM.jl. The masses M_mathrme and M_mathrmI are given simply in kilograms. The damping coefficients B_mathrme and B_mathrmI are given simply in kilograms per second. The spring constants K_mathrme and K_mathrmI are given simply in kilograms per second squared (or, equivalently, newtons per meter). Only the charges Q_mathrme must be treated with a little more care: they must be given in Lorentz-Heaviside SI units, where the conversion formula from standard SI may be written as q_mathrmLHSI = q_mathrmSI  sqrtepsilon_0(mathrmSI), and the result is specified in mathrmkg^12 cdot mathrmm^32 cdot mathrms^-1.","category":"page"},{"location":"implementation/units.html#Units-of-output-polarizabilities-and-Green's-functions-1","page":"Units","title":"Units of output polarizabilities and Green's functions","text":"","category":"section"},{"location":"implementation/units.html#","page":"Units","title":"Units","text":"AARMBEM.jl frequently makes use of atomic polarizabilities as well as Green's function components, whether as effective per-atom quantities or as full matrices. In either case, polarizabilities are in units of cubic meters (so multiplying by epsilon_0, with no additional factors of 4pi, recovers the SI values), and Green's functions are in units of inverse cubic meters. The Green's function matrices, inverse polarizability matrices, and inverse T-operator matrices all have the same units (inverse cubic meters).","category":"page"},{"location":"usage/freqkfiles.html#Frequency-and-Bloch-wavevector-files-1","page":"Frequency and Bloch wavevector files","title":"Frequency and Bloch wavevector files","text":"","category":"section"},{"location":"usage/freqkfiles.html#","page":"Frequency and Bloch wavevector files","title":"Frequency and Bloch wavevector files","text":"note: Note\nSpecification of Bloch wavevectors by command-line arguments or by input files is optional, and will be ignored when there are no Bloch periodic boundary conditions (discrete translational symmetries).","category":"page"},{"location":"usage/freqkfiles.html#","page":"Frequency and Bloch wavevector files","title":"Frequency and Bloch wavevector files","text":"note: Note\nFor vdW interaction free energies, all frequency inputs w will be interpreted as omega = mathrmivert wvert. For thermal radiation powers, all frequency inputs w will be interpreted as omega = vert wvert.","category":"page"},{"location":"usage/freqkfiles.html#","page":"Frequency and Bloch wavevector files","title":"Frequency and Bloch wavevector files","text":"Frequencies and Bloch wavevectors may be supplied to the programs in AARMBEM.jl as command-line arguments or as input files. This page goes over the format of the latter.","category":"page"},{"location":"usage/freqkfiles.html#Frequency-file-structure-1","page":"Frequency and Bloch wavevector files","title":"Frequency file structure","text":"","category":"section"},{"location":"usage/freqkfiles.html#","page":"Frequency and Bloch wavevector files","title":"Frequency and Bloch wavevector files","text":"Frequencies should be specified in a file in the following structure:","category":"page"},{"location":"usage/freqkfiles.html#","page":"Frequency and Bloch wavevector files","title":"Frequency and Bloch wavevector files","text":"freq1\nfreq2\n...\nfreqN","category":"page"},{"location":"usage/freqkfiles.html#","page":"Frequency and Bloch wavevector files","title":"Frequency and Bloch wavevector files","text":"with each value (freq1, freq2, et cetera) being replaced by a real (currently, AARMBEM.jl does not support evaluation at arbitrary complex frequencies, but this can be changed relatively easily in the source code) floating-point number (possible in scientific notation), with one value per line, and with no extraneous characters, spaces, or blank lines. A file with a single frequency is valid. Frequencies should be given in units of radians per second.","category":"page"},{"location":"usage/freqkfiles.html#Bloch-wavevector-file-structure-1","page":"Frequency and Bloch wavevector files","title":"Bloch wavevector file structure","text":"","category":"section"},{"location":"usage/freqkfiles.html#","page":"Frequency and Bloch wavevector files","title":"Frequency and Bloch wavevector files","text":"Bloch wavevectors should be specified in a file in the following structure:","category":"page"},{"location":"usage/freqkfiles.html#","page":"Frequency and Bloch wavevector files","title":"Frequency and Bloch wavevector files","text":"k1x k1y k1z\nk2x k2y k2z\n...\nkNx kNy kNz","category":"page"},{"location":"usage/freqkfiles.html#","page":"Frequency and Bloch wavevector files","title":"Frequency and Bloch wavevector files","text":"with each value (k1x, k1y, et cetera) being replaced by a real floating-point number (possible in scientific notation), with three values per line separated by exactly a single space to represent the Cartesian components of the Bloch wavevector, and with no extraneous characters, spaces, or blank lines. A file with a single Bloch wavevector is valid, but it must contain all three components explicitly. Wavevectors should be given in units of radians per meter.","category":"page"},{"location":"api/periodicdata.html#Bloch-periodicity-1","page":"Data structures and functions for Bloch periodicity","title":"Bloch periodicity","text":"","category":"section"},{"location":"api/periodicdata.html#","page":"Data structures and functions for Bloch periodicity","title":"Data structures and functions for Bloch periodicity","text":"These data structures and functions may be useful outside of AARMBEM.jl","category":"page"},{"location":"api/periodicdata.html#Data-structures-1","page":"Data structures and functions for Bloch periodicity","title":"Data structures","text":"","category":"section"},{"location":"api/periodicdata.html#","page":"Data structures and functions for Bloch periodicity","title":"Data structures and functions for Bloch periodicity","text":"PeriodicData","category":"page"},{"location":"api/periodicdata.html#PeriodicData","page":"Data structures and functions for Bloch periodicity","title":"PeriodicData","text":"PeriodicData{FT<:AbstractFloat}\n\nStore information relevant to spatial periodicity in a system. numdims should be 0, 1, or 2, representing the number of periodic dimensions. latticevecs and reciprocalvecs should each by 3-by-2 matrices, with each column representing a 3-element lattice or corresponding reciprocal vector, with the vector being zeros along a dimension with no periodicity.\n\n\n\n\n\n","category":"type"},{"location":"api/periodicdata.html#Functions-1","page":"Data structures and functions for Bloch periodicity","title":"Functions","text":"","category":"section"},{"location":"api/periodicdata.html#","page":"Data structures and functions for Bloch periodicity","title":"Data structures and functions for Bloch periodicity","text":"readPeriodicData\nconstructlatticefromreciprocal!\nconstructreciprocalfromlattice!","category":"page"},{"location":"api/periodicdata.html#readPeriodicData","page":"Data structures and functions for Bloch periodicity","title":"readPeriodicData","text":"readPeriodicData(FT::DataType=Float64, periodicfilename::AbstractString=\"\")\n\nConstruct PeriodicData from an appropriate floating-point data type FT and a file of name periodicfilename containing information about spatial periodicity; if no file is specified, produce a default set of periodic data (no spatial periodicity at all).\n\n\n\n\n\n","category":"function"},{"location":"api/periodicdata.html#constructlatticefromreciprocal!","page":"Data structures and functions for Bloch periodicity","title":"constructlatticefromreciprocal!","text":"constructlatticefromreciprocal!(myPeriodicData::PeriodicData{<:AbstractFloat})\n\nReset the lattice vectors of myPeriodicData from its reciprocal vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/periodicdata.html#constructreciprocalfromlattice!","page":"Data structures and functions for Bloch periodicity","title":"constructreciprocalfromlattice!","text":"constructreciprocalfromlattice!(myPeriodicData::PeriodicData{<:AbstractFloat})\n\nReset the reciprocal vectors of myPeriodicData from its lattice vectors.\n\n\n\n\n\n","category":"function"},{"location":"index.html#AARMBEM.jl-1","page":"Home","title":"AARMBEM.jl","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"AARMBEM.jl is a code to compute electromagnetic (EM) interactions, particularly fluctuational EM interactions, at the nanoscale, via the retarded many-body (RMB) framework. In particular, the RMB framework computes fluctuational EM interactions among material bodies that may scale from single atoms or small compact molecules to infinitely long atomic-scale wires or sheets, in vacuum or in the presence of macroscopic bodies. AARMBEM.jl is a computational implementation of the RMB framework.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Currently, two codes are available. One computes van der Waals (vdW) interaction energies in such systems, while the other computes thermal radiation powers in such systems. Thus, the focus is on fluctuational phenomena. However, the theory and the API are general enough that others may extend this code to perform computations of deterministic EM phenomena, like absorbed or scattered powers from a specified incident field/polarization source, local densities of states, et cetera.","category":"page"},{"location":"index.html#Name-1","page":"Home","title":"Name","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The name \"AARMBEM\" is an acronym, expanded to \"Ab-initio Atomistic Retarded Many-Body Electromagnetics at the Mesoscale\". It may be pronounced as \"aarambham\", identical to a word common in Indian languages meaning \"beginning\" or \"ab-initio\".","category":"page"},{"location":"index.html#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"AARMBEM.jl is now a module that can be properly installed and used.","category":"page"},{"location":"implementation/performancenotes.html#Performance-notes-and-required-packages-1","page":"Performance notes and required packages","title":"Performance notes and required packages","text":"","category":"section"},{"location":"implementation/performancenotes.html#","page":"Performance notes and required packages","title":"Performance notes and required packages","text":"AARMBEM.jl has been written in Julia. It has been tested in Julia 1.0. It requires the modules LinearAlgebra, DelimitedFiles, SharedArrays, SpecialFunctions, Distributed, and Printf.","category":"page"},{"location":"implementation/performancenotes.html#","page":"Performance notes and required packages","title":"Performance notes and required packages","text":"AARMBEM.jl has been written with parallelism in mind. In particular, the functions for assembling the Green's function matrices make use of parallel for-loops. However, while the programs in AARMBEM.jl may be invoked using parallel processing via a command like julia -p N (followed by the command as well as any arguments) for a number of processors N larger than 1, testing thus far has showed this to be somewhat unreliable on certain setups. Therefore, it is recommended that N be set to 1, and that parallelism be done instead over frequencies (and Bloch wavevectors, if appropriate), as that process can be done in an embarrassingly parallel manner (i.e. with each set of frequencies (and Bloch wavevectors, if appropriate) constituting a single job). This is particularly suitable for use in a script, especially one that interfaces with a job scheduler like SLURM.","category":"page"},{"location":"implementation/performancenotes.html#","page":"Performance notes and required packages","title":"Performance notes and required packages","text":"Even with embarrassing parallelism (using one frequency, and one Bloch wavevector, if appropriate, per job, and one processor per job), AARMBEM.jl has been seen to occasionally fail to produce output in certain random instances. These generally have not been predictable, so users who wish to run a calculation over a large number of frequencies (and Bloch wavevectors, if appropriate) for a large number of geometric configurations of a given set of molecular and macroscopic bodies may need to rerun calculations for certain combinations of frequency (and Bloch wavevector, if appropriate) and geometric configuration after the fact.","category":"page"},{"location":"implementation/performancenotes.html#","page":"Performance notes and required packages","title":"Performance notes and required packages","text":"As discussed in other pages, the code for molecular bodies of infinite extent obeying Bloch periodic boundary conditions is sometimes less numerically stable. As an example, it has been observed that calculations of the vdW interaction free energy integrand of a graphene sheet at a distance z above and parallel to a PEC plane (at z = 0) for a few combinations (mathrmixi veck z) (far fewer than the total number sampled) has the wrong sign or magnitude. Such occurrences are rare and isolated incidents and can be mitigated through interpolation as needed, though there may be other systems where none of the data is reliable or trustworthy; users must use their best judgment to determine how to proceed.","category":"page"}]
}
